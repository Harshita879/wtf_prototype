"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/chat/route";
exports.ids = ["app/api/chat/route"];
exports.modules = {

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("fs");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("path");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fchat%2Froute&page=%2Fapi%2Fchat%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fchat%2Froute.ts&appDir=C%3A%5CUsers%5Cprafu%5CDownloads%5Cwtf_prototype%5Csrc%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5Cprafu%5CDownloads%5Cwtf_prototype&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!":
/*!**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fchat%2Froute&page=%2Fapi%2Fchat%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fchat%2Froute.ts&appDir=C%3A%5CUsers%5Cprafu%5CDownloads%5Cwtf_prototype%5Csrc%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5Cprafu%5CDownloads%5Cwtf_prototype&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D! ***!
  \**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   originalPathname: () => (/* binding */ originalPathname),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   requestAsyncStorage: () => (/* binding */ requestAsyncStorage),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   staticGenerationAsyncStorage: () => (/* binding */ staticGenerationAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(rsc)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var C_Users_prafu_Downloads_wtf_prototype_src_app_api_chat_route_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/app/api/chat/route.ts */ \"(rsc)/./src/app/api/chat/route.ts\");\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/chat/route\",\n        pathname: \"/api/chat\",\n        filename: \"route\",\n        bundlePath: \"app/api/chat/route\"\n    },\n    resolvedPagePath: \"C:\\\\Users\\\\prafu\\\\Downloads\\\\wtf_prototype\\\\src\\\\app\\\\api\\\\chat\\\\route.ts\",\n    nextConfigOutput,\n    userland: C_Users_prafu_Downloads_wtf_prototype_src_app_api_chat_route_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { requestAsyncStorage, staticGenerationAsyncStorage, serverHooks } = routeModule;\nconst originalPathname = \"/api/chat/route\";\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        serverHooks,\n        staticGenerationAsyncStorage\n    });\n}\n\n\n//# sourceMappingURL=app-route.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIuanM/bmFtZT1hcHAlMkZhcGklMkZjaGF0JTJGcm91dGUmcGFnZT0lMkZhcGklMkZjaGF0JTJGcm91dGUmYXBwUGF0aHM9JnBhZ2VQYXRoPXByaXZhdGUtbmV4dC1hcHAtZGlyJTJGYXBpJTJGY2hhdCUyRnJvdXRlLnRzJmFwcERpcj1DJTNBJTVDVXNlcnMlNUNwcmFmdSU1Q0Rvd25sb2FkcyU1Q3d0Zl9wcm90b3R5cGUlNUNzcmMlNUNhcHAmcGFnZUV4dGVuc2lvbnM9dHN4JnBhZ2VFeHRlbnNpb25zPXRzJnBhZ2VFeHRlbnNpb25zPWpzeCZwYWdlRXh0ZW5zaW9ucz1qcyZyb290RGlyPUMlM0ElNUNVc2VycyU1Q3ByYWZ1JTVDRG93bmxvYWRzJTVDd3RmX3Byb3RvdHlwZSZpc0Rldj10cnVlJnRzY29uZmlnUGF0aD10c2NvbmZpZy5qc29uJmJhc2VQYXRoPSZhc3NldFByZWZpeD0mbmV4dENvbmZpZ091dHB1dD0mcHJlZmVycmVkUmVnaW9uPSZtaWRkbGV3YXJlQ29uZmlnPWUzMCUzRCEiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQXNHO0FBQ3ZDO0FBQ2M7QUFDeUI7QUFDdEc7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdIQUFtQjtBQUMzQztBQUNBLGNBQWMseUVBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFlBQVk7QUFDWixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpRUFBaUU7QUFDekU7QUFDQTtBQUNBLFdBQVcsNEVBQVc7QUFDdEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUN1SDs7QUFFdkgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93dGYtcG9kY2FzdC8/YTQ0YyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBcHBSb3V0ZVJvdXRlTW9kdWxlIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLW1vZHVsZXMvYXBwLXJvdXRlL21vZHVsZS5jb21waWxlZFwiO1xuaW1wb3J0IHsgUm91dGVLaW5kIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLWtpbmRcIjtcbmltcG9ydCB7IHBhdGNoRmV0Y2ggYXMgX3BhdGNoRmV0Y2ggfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9saWIvcGF0Y2gtZmV0Y2hcIjtcbmltcG9ydCAqIGFzIHVzZXJsYW5kIGZyb20gXCJDOlxcXFxVc2Vyc1xcXFxwcmFmdVxcXFxEb3dubG9hZHNcXFxcd3RmX3Byb3RvdHlwZVxcXFxzcmNcXFxcYXBwXFxcXGFwaVxcXFxjaGF0XFxcXHJvdXRlLnRzXCI7XG4vLyBXZSBpbmplY3QgdGhlIG5leHRDb25maWdPdXRwdXQgaGVyZSBzbyB0aGF0IHdlIGNhbiB1c2UgdGhlbSBpbiB0aGUgcm91dGVcbi8vIG1vZHVsZS5cbmNvbnN0IG5leHRDb25maWdPdXRwdXQgPSBcIlwiXG5jb25zdCByb3V0ZU1vZHVsZSA9IG5ldyBBcHBSb3V0ZVJvdXRlTW9kdWxlKHtcbiAgICBkZWZpbml0aW9uOiB7XG4gICAgICAgIGtpbmQ6IFJvdXRlS2luZC5BUFBfUk9VVEUsXG4gICAgICAgIHBhZ2U6IFwiL2FwaS9jaGF0L3JvdXRlXCIsXG4gICAgICAgIHBhdGhuYW1lOiBcIi9hcGkvY2hhdFwiLFxuICAgICAgICBmaWxlbmFtZTogXCJyb3V0ZVwiLFxuICAgICAgICBidW5kbGVQYXRoOiBcImFwcC9hcGkvY2hhdC9yb3V0ZVwiXG4gICAgfSxcbiAgICByZXNvbHZlZFBhZ2VQYXRoOiBcIkM6XFxcXFVzZXJzXFxcXHByYWZ1XFxcXERvd25sb2Fkc1xcXFx3dGZfcHJvdG90eXBlXFxcXHNyY1xcXFxhcHBcXFxcYXBpXFxcXGNoYXRcXFxccm91dGUudHNcIixcbiAgICBuZXh0Q29uZmlnT3V0cHV0LFxuICAgIHVzZXJsYW5kXG59KTtcbi8vIFB1bGwgb3V0IHRoZSBleHBvcnRzIHRoYXQgd2UgbmVlZCB0byBleHBvc2UgZnJvbSB0aGUgbW9kdWxlLiBUaGlzIHNob3VsZFxuLy8gYmUgZWxpbWluYXRlZCB3aGVuIHdlJ3ZlIG1vdmVkIHRoZSBvdGhlciByb3V0ZXMgdG8gdGhlIG5ldyBmb3JtYXQuIFRoZXNlXG4vLyBhcmUgdXNlZCB0byBob29rIGludG8gdGhlIHJvdXRlLlxuY29uc3QgeyByZXF1ZXN0QXN5bmNTdG9yYWdlLCBzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlLCBzZXJ2ZXJIb29rcyB9ID0gcm91dGVNb2R1bGU7XG5jb25zdCBvcmlnaW5hbFBhdGhuYW1lID0gXCIvYXBpL2NoYXQvcm91dGVcIjtcbmZ1bmN0aW9uIHBhdGNoRmV0Y2goKSB7XG4gICAgcmV0dXJuIF9wYXRjaEZldGNoKHtcbiAgICAgICAgc2VydmVySG9va3MsXG4gICAgICAgIHN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2VcbiAgICB9KTtcbn1cbmV4cG9ydCB7IHJvdXRlTW9kdWxlLCByZXF1ZXN0QXN5bmNTdG9yYWdlLCBzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlLCBzZXJ2ZXJIb29rcywgb3JpZ2luYWxQYXRobmFtZSwgcGF0Y2hGZXRjaCwgIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwcC1yb3V0ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fchat%2Froute&page=%2Fapi%2Fchat%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fchat%2Froute.ts&appDir=C%3A%5CUsers%5Cprafu%5CDownloads%5Cwtf_prototype%5Csrc%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5Cprafu%5CDownloads%5Cwtf_prototype&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!\n");

/***/ }),

/***/ "(rsc)/./src/app/api/chat/route.ts":
/*!***********************************!*\
  !*** ./src/app/api/chat/route.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GET: () => (/* binding */ GET),\n/* harmony export */   OPTIONS: () => (/* binding */ OPTIONS),\n/* harmony export */   POST: () => (/* binding */ POST)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/next/dist/api/server.js\");\n/* harmony import */ var _lib_ai__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../lib/ai */ \"(rsc)/./src/lib/ai.ts\");\n\n\nasync function POST(request) {\n    try {\n        const { message, useEnhanced = false } = await request.json();\n        if (!message || typeof message !== \"string\") {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Valid message is required\"\n            }, {\n                status: 400\n            });\n        }\n        const cleanMessage = message.trim();\n        if (cleanMessage.length === 0) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Message cannot be empty\"\n            }, {\n                status: 400\n            });\n        }\n        // Rate limiting check (optional)\n        if (cleanMessage.length > 500) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Message too long. Please keep it under 500 characters.\"\n            }, {\n                status: 400\n            });\n        }\n        let response;\n        let processingTime;\n        const startTime = Date.now();\n        try {\n            // For now, use the original system (enhanced system will be integrated later)\n            console.log(\"\\uD83D\\uDCDD Using RAG system...\");\n            response = await (0,_lib_ai__WEBPACK_IMPORTED_MODULE_1__.generateResponse)(cleanMessage);\n            processingTime = Date.now() - startTime;\n            console.log(`‚úÖ Response generated in ${processingTime}ms`);\n        } catch (error) {\n            console.error(\"AI generation error:\", error);\n            response = (0,_lib_ai__WEBPACK_IMPORTED_MODULE_1__.getQuickResponse)(cleanMessage);\n            processingTime = Date.now() - startTime;\n        }\n        // Add response metadata\n        const responseData = {\n            response: response,\n            metadata: {\n                processingTime: processingTime,\n                systemUsed: useEnhanced ? \"enhanced\" : \"original\",\n                timestamp: new Date().toISOString(),\n                messageLength: cleanMessage.length\n            }\n        };\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json(responseData);\n    } catch (error) {\n        console.error(\"Chat API error:\", error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            error: \"Something went wrong! Please try again.\",\n            timestamp: new Date().toISOString()\n        }, {\n            status: 500\n        });\n    }\n}\nasync function GET(request) {\n    try {\n        const { searchParams } = new URL(request.url);\n        const action = searchParams.get(\"action\");\n        // System status endpoint\n        if (action === \"status\") {\n            console.log(\"\\uD83D\\uDCCA Checking system status...\");\n            try {\n                const status = await (0,_lib_ai__WEBPACK_IMPORTED_MODULE_1__.getSystemStatus)();\n                return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                    status: \"WTF Podcast AI is running! \\uD83E\\uDD16\",\n                    systemDetails: JSON.parse(status),\n                    timestamp: new Date().toISOString()\n                });\n            } catch (error) {\n                console.error(\"Status check failed:\", error);\n                return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                    status: \"System status check failed\",\n                    error: error instanceof Error ? error.message : \"Unknown error\",\n                    timestamp: new Date().toISOString()\n                }, {\n                    status: 500\n                });\n            }\n        }\n        // Health check endpoint\n        if (action === \"health\") {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                status: \"healthy\",\n                service: \"WTF Podcast AI\",\n                version: \"2.0.0\",\n                features: {\n                    ragRetrieval: true,\n                    semanticSearch: true,\n                    keywordFallback: true\n                },\n                timestamp: new Date().toISOString()\n            });\n        }\n        // Default response\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            status: \"WTF Podcast AI is running! \\uD83E\\uDD16\",\n            message: \"Send a POST request with your question\",\n            endpoints: {\n                chat: \"POST /\",\n                status: \"GET /?action=status\",\n                health: \"GET /?action=health\"\n            },\n            timestamp: new Date().toISOString()\n        });\n    } catch (error) {\n        console.error(\"GET endpoint error:\", error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            error: \"Failed to process request\",\n            timestamp: new Date().toISOString()\n        }, {\n            status: 500\n        });\n    }\n}\n// Optional: Add OPTIONS for CORS if needed\nasync function OPTIONS(request) {\n    return new next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse(null, {\n        status: 200,\n        headers: {\n            \"Access-Control-Allow-Origin\": \"*\",\n            \"Access-Control-Allow-Methods\": \"GET, POST, OPTIONS\",\n            \"Access-Control-Allow-Headers\": \"Content-Type\"\n        }\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QkFBRWYsUUFBUTtnQkFBSTtZQUNuQjtRQUNGO1FBRUEsd0JBQXdCO1FBQ3hCLElBQUlxQixXQUFXLFVBQVU7WUFDdkIsT0FBTy9CLHFEQUFZQSxDQUFDUSxJQUFJLENBQUM7Z0JBQ3ZCRSxRQUFRO2dCQUNSMkIsU0FBUztnQkFDVEMsU0FBUztnQkFDVEMsVUFBVTtvQkFDUkMsY0FBYztvQkFDZEMsZ0JBQWdCO29CQUNoQkMsaUJBQWlCO2dCQUNuQjtnQkFDQWxCLFdBQVcsSUFBSVAsT0FBT1EsV0FBVztZQUNuQztRQUNGO1FBRUEsbUJBQW1CO1FBQ25CLE9BQU96QixxREFBWUEsQ0FBQ1EsSUFBSSxDQUFDO1lBQ3ZCRSxRQUFRO1lBQ1JKLFNBQVM7WUFDVHFDLFdBQVc7Z0JBQ1RDLE1BQU07Z0JBQ05sQyxRQUFRO2dCQUNSbUMsUUFBUTtZQUNWO1lBQ0FyQixXQUFXLElBQUlQLE9BQU9RLFdBQVc7UUFDbkM7SUFFRixFQUFFLE9BQU9oQixPQUFPO1FBQ2RVLFFBQVFWLEtBQUssQ0FBQyx1QkFBdUJBO1FBQ3JDLE9BQU9ULHFEQUFZQSxDQUFDUSxJQUFJLENBQ3RCO1lBQ0VDLE9BQU87WUFDUGUsV0FBVyxJQUFJUCxPQUFPUSxXQUFXO1FBQ25DLEdBQ0E7WUFBRWYsUUFBUTtRQUFJO0lBRWxCO0FBQ0Y7QUFFQSwyQ0FBMkM7QUFDcEMsZUFBZW9DLFFBQVF6QyxPQUFvQjtJQUNoRCxPQUFPLElBQUlMLHFEQUFZQSxDQUFDLE1BQU07UUFDNUJVLFFBQVE7UUFDUnFDLFNBQVM7WUFDUCwrQkFBK0I7WUFDL0IsZ0NBQWdDO1lBQ2hDLGdDQUFnQztRQUNsQztJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93dGYtcG9kY2FzdC8uL3NyYy9hcHAvYXBpL2NoYXQvcm91dGUudHM/NDZiNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOZXh0UmVxdWVzdCwgTmV4dFJlc3BvbnNlIH0gZnJvbSAnbmV4dC9zZXJ2ZXInXG5pbXBvcnQgeyBnZW5lcmF0ZVJlc3BvbnNlLCBnZXRRdWlja1Jlc3BvbnNlLCBnZXRTeXN0ZW1TdGF0dXMgfSBmcm9tICcuLi8uLi8uLi9saWIvYWknXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBQT1NUKHJlcXVlc3Q6IE5leHRSZXF1ZXN0KSB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBtZXNzYWdlLCB1c2VFbmhhbmNlZCA9IGZhbHNlIH0gPSBhd2FpdCByZXF1ZXN0Lmpzb24oKVxuICAgIFxuICAgIGlmICghbWVzc2FnZSB8fCB0eXBlb2YgbWVzc2FnZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7IGVycm9yOiAnVmFsaWQgbWVzc2FnZSBpcyByZXF1aXJlZCcgfSwgeyBzdGF0dXM6IDQwMCB9KVxuICAgIH1cbiAgICBcbiAgICBjb25zdCBjbGVhbk1lc3NhZ2UgPSBtZXNzYWdlLnRyaW0oKVxuICAgIFxuICAgIGlmIChjbGVhbk1lc3NhZ2UubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oeyBlcnJvcjogJ01lc3NhZ2UgY2Fubm90IGJlIGVtcHR5JyB9LCB7IHN0YXR1czogNDAwIH0pXG4gICAgfVxuICAgIFxuICAgIC8vIFJhdGUgbGltaXRpbmcgY2hlY2sgKG9wdGlvbmFsKVxuICAgIGlmIChjbGVhbk1lc3NhZ2UubGVuZ3RoID4gNTAwKSB7XG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oeyBlcnJvcjogJ01lc3NhZ2UgdG9vIGxvbmcuIFBsZWFzZSBrZWVwIGl0IHVuZGVyIDUwMCBjaGFyYWN0ZXJzLicgfSwgeyBzdGF0dXM6IDQwMCB9KVxuICAgIH1cbiAgICBcbiAgICBsZXQgcmVzcG9uc2U6IHN0cmluZ1xuICAgIGxldCBwcm9jZXNzaW5nVGltZTogbnVtYmVyXG4gICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKVxuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBGb3Igbm93LCB1c2UgdGhlIG9yaWdpbmFsIHN5c3RlbSAoZW5oYW5jZWQgc3lzdGVtIHdpbGwgYmUgaW50ZWdyYXRlZCBsYXRlcilcbiAgICAgIGNvbnNvbGUubG9nKCfwn5OdIFVzaW5nIFJBRyBzeXN0ZW0uLi4nKVxuICAgICAgcmVzcG9uc2UgPSBhd2FpdCBnZW5lcmF0ZVJlc3BvbnNlKGNsZWFuTWVzc2FnZSlcbiAgICAgIFxuICAgICAgcHJvY2Vzc2luZ1RpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lXG4gICAgICBjb25zb2xlLmxvZyhg4pyFIFJlc3BvbnNlIGdlbmVyYXRlZCBpbiAke3Byb2Nlc3NpbmdUaW1lfW1zYClcbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdBSSBnZW5lcmF0aW9uIGVycm9yOicsIGVycm9yKVxuICAgICAgcmVzcG9uc2UgPSBnZXRRdWlja1Jlc3BvbnNlKGNsZWFuTWVzc2FnZSlcbiAgICAgIHByb2Nlc3NpbmdUaW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZVxuICAgIH1cbiAgICBcbiAgICAvLyBBZGQgcmVzcG9uc2UgbWV0YWRhdGFcbiAgICBjb25zdCByZXNwb25zZURhdGEgPSB7XG4gICAgICByZXNwb25zZTogcmVzcG9uc2UsXG4gICAgICBtZXRhZGF0YToge1xuICAgICAgICBwcm9jZXNzaW5nVGltZTogcHJvY2Vzc2luZ1RpbWUsXG4gICAgICAgIHN5c3RlbVVzZWQ6IHVzZUVuaGFuY2VkID8gJ2VuaGFuY2VkJyA6ICdvcmlnaW5hbCcsXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICBtZXNzYWdlTGVuZ3RoOiBjbGVhbk1lc3NhZ2UubGVuZ3RoXG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihyZXNwb25zZURhdGEpXG4gICAgXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignQ2hhdCBBUEkgZXJyb3I6JywgZXJyb3IpXG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgeyBcbiAgICAgICAgZXJyb3I6ICdTb21ldGhpbmcgd2VudCB3cm9uZyEgUGxlYXNlIHRyeSBhZ2Fpbi4nLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgfSwgXG4gICAgICB7IHN0YXR1czogNTAwIH1cbiAgICApXG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIEdFVChyZXF1ZXN0OiBOZXh0UmVxdWVzdCkge1xuICB0cnkge1xuICAgIGNvbnN0IHsgc2VhcmNoUGFyYW1zIH0gPSBuZXcgVVJMKHJlcXVlc3QudXJsKVxuICAgIGNvbnN0IGFjdGlvbiA9IHNlYXJjaFBhcmFtcy5nZXQoJ2FjdGlvbicpXG4gICAgXG4gICAgLy8gU3lzdGVtIHN0YXR1cyBlbmRwb2ludFxuICAgIGlmIChhY3Rpb24gPT09ICdzdGF0dXMnKSB7XG4gICAgICBjb25zb2xlLmxvZygn8J+TiiBDaGVja2luZyBzeXN0ZW0gc3RhdHVzLi4uJylcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IGF3YWl0IGdldFN5c3RlbVN0YXR1cygpXG4gICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7XG4gICAgICAgICAgc3RhdHVzOiAnV1RGIFBvZGNhc3QgQUkgaXMgcnVubmluZyEg8J+klicsXG4gICAgICAgICAgc3lzdGVtRGV0YWlsczogSlNPTi5wYXJzZShzdGF0dXMpLFxuICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgIH0pXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdTdGF0dXMgY2hlY2sgZmFpbGVkOicsIGVycm9yKVxuICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oe1xuICAgICAgICAgIHN0YXR1czogJ1N5c3RlbSBzdGF0dXMgY2hlY2sgZmFpbGVkJyxcbiAgICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcicsXG4gICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgfSwgeyBzdGF0dXM6IDUwMCB9KVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBIZWFsdGggY2hlY2sgZW5kcG9pbnRcbiAgICBpZiAoYWN0aW9uID09PSAnaGVhbHRoJykge1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcbiAgICAgICAgc3RhdHVzOiAnaGVhbHRoeScsXG4gICAgICAgIHNlcnZpY2U6ICdXVEYgUG9kY2FzdCBBSScsXG4gICAgICAgIHZlcnNpb246ICcyLjAuMCcsXG4gICAgICAgIGZlYXR1cmVzOiB7XG4gICAgICAgICAgcmFnUmV0cmlldmFsOiB0cnVlLFxuICAgICAgICAgIHNlbWFudGljU2VhcmNoOiB0cnVlLFxuICAgICAgICAgIGtleXdvcmRGYWxsYmFjazogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgfSlcbiAgICB9XG4gICAgXG4gICAgLy8gRGVmYXVsdCByZXNwb25zZVxuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7IFxuICAgICAgc3RhdHVzOiAnV1RGIFBvZGNhc3QgQUkgaXMgcnVubmluZyEg8J+klicsXG4gICAgICBtZXNzYWdlOiAnU2VuZCBhIFBPU1QgcmVxdWVzdCB3aXRoIHlvdXIgcXVlc3Rpb24nLFxuICAgICAgZW5kcG9pbnRzOiB7XG4gICAgICAgIGNoYXQ6ICdQT1NUIC8nLFxuICAgICAgICBzdGF0dXM6ICdHRVQgLz9hY3Rpb249c3RhdHVzJyxcbiAgICAgICAgaGVhbHRoOiAnR0VUIC8/YWN0aW9uPWhlYWx0aCdcbiAgICAgIH0sXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgIH0pXG4gICAgXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignR0VUIGVuZHBvaW50IGVycm9yOicsIGVycm9yKVxuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgIHsgXG4gICAgICAgIGVycm9yOiAnRmFpbGVkIHRvIHByb2Nlc3MgcmVxdWVzdCcsXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICB9LCBcbiAgICAgIHsgc3RhdHVzOiA1MDAgfVxuICAgIClcbiAgfVxufVxuXG4vLyBPcHRpb25hbDogQWRkIE9QVElPTlMgZm9yIENPUlMgaWYgbmVlZGVkXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gT1BUSU9OUyhyZXF1ZXN0OiBOZXh0UmVxdWVzdCkge1xuICByZXR1cm4gbmV3IE5leHRSZXNwb25zZShudWxsLCB7XG4gICAgc3RhdHVzOiAyMDAsXG4gICAgaGVhZGVyczoge1xuICAgICAgJ0FjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpbic6ICcqJyxcbiAgICAgICdBY2Nlc3MtQ29udHJvbC1BbGxvdy1NZXRob2RzJzogJ0dFVCwgUE9TVCwgT1BUSU9OUycsXG4gICAgICAnQWNjZXNzLUNvbnRyb2wtQWxsb3ctSGVhZGVycyc6ICdDb250ZW50LVR5cGUnLFxuICAgIH0sXG4gIH0pXG59Il0sIm5hbWVzIjpbIk5leHRSZXNwb25zZSIsImdlbmVyYXRlUmVzcG9uc2UiLCJnZXRRdWlja1Jlc3BvbnNlIiwiZ2V0U3lzdGVtU3RhdHVzIiwiUE9TVCIsInJlcXVlc3QiLCJtZXNzYWdlIiwidXNlRW5oYW5jZWQiLCJqc29uIiwiZXJyb3IiLCJzdGF0dXMiLCJjbGVhbk1lc3NhZ2UiLCJ0cmltIiwibGVuZ3RoIiwicmVzcG9uc2UiLCJwcm9jZXNzaW5nVGltZSIsInN0YXJ0VGltZSIsIkRhdGUiLCJub3ciLCJjb25zb2xlIiwibG9nIiwicmVzcG9uc2VEYXRhIiwibWV0YWRhdGEiLCJzeXN0ZW1Vc2VkIiwidGltZXN0YW1wIiwidG9JU09TdHJpbmciLCJtZXNzYWdlTGVuZ3RoIiwiR0VUIiwic2VhcmNoUGFyYW1zIiwiVVJMIiwidXJsIiwiYWN0aW9uIiwiZ2V0Iiwic3lzdGVtRGV0YWlscyIsIkpTT04iLCJwYXJzZSIsIkVycm9yIiwic2VydmljZSIsInZlcnNpb24iLCJmZWF0dXJlcyIsInJhZ1JldHJpZXZhbCIsInNlbWFudGljU2VhcmNoIiwia2V5d29yZEZhbGxiYWNrIiwiZW5kcG9pbnRzIiwiY2hhdCIsImhlYWx0aCIsIk9QVElPTlMiLCJoZWFkZXJzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/app/api/chat/route.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/ai.ts":
/*!***********************!*\
  !*** ./src/lib/ai.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateEnhancedResponse: () => (/* binding */ generateEnhancedResponse),\n/* harmony export */   generateResponse: () => (/* binding */ generateResponse),\n/* harmony export */   getQuickResponse: () => (/* binding */ getQuickResponse),\n/* harmony export */   getSystemStatus: () => (/* binding */ getSystemStatus)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);\n// lib/ai.ts\n// Enhanced podcast Q&A system with improved response formatting\n\n\n// --- CONFIGURATION ---\nconst GROQ_API_KEY = process.env.GROQ_API_KEY;\nconst OPENAI_API_KEY = process.env.OPENAI_API_KEY;\nif (!GROQ_API_KEY) {\n    console.error(\"‚ùå GROQ_API_KEY environment variable is required\");\n}\nif (!OPENAI_API_KEY) {\n    console.error(\"‚ùå OPENAI_API_KEY environment variable is required\");\n}\n// --- GLOBAL STATE ---\nlet chunks = [];\nlet enhancedChunks = [];\nlet isReady = false;\nlet isEnhancedReady = false;\nlet initError = null;\n// --- HELPER FUNCTIONS ---\nfunction log(message, data) {\n    console.log(`[AI] ${message}`, data ? JSON.stringify(data, null, 2) : \"\");\n}\n// Calculate similarity between two vectors\nfunction similarity(a, b) {\n    if (!a || !b || a.length !== b.length) return 0;\n    let dot = 0, magA = 0, magB = 0;\n    for(let i = 0; i < a.length; i++){\n        dot += a[i] * b[i];\n        magA += a[i] * a[i];\n        magB += b[i] * b[i];\n    }\n    const magnitude = Math.sqrt(magA * magB);\n    return magnitude > 0 ? dot / magnitude : 0;\n}\n// Enhanced cosine similarity (handles undefined)\nfunction cosineSimilarity(a, b) {\n    if (!a || !b || a.length !== b.length || a.length === 0) return 0;\n    let dot = 0, magA = 0, magB = 0;\n    for(let i = 0; i < a.length; i++){\n        dot += a[i] * b[i];\n        magA += a[i] * a[i];\n        magB += b[i] * b[i];\n    }\n    const magnitude = Math.sqrt(magA * magB);\n    return magnitude > 0 ? dot / magnitude : 0;\n}\n// Get embedding from OpenAI with detailed error handling\nasync function getEmbedding(text) {\n    if (!OPENAI_API_KEY) {\n        log(\"‚ùå No OpenAI API key provided\");\n        return undefined;\n    }\n    if (!text.trim() || text.trim().length < 10) {\n        log(\"‚ùå Text too short for embedding\");\n        return undefined;\n    }\n    try {\n        log(`üîÑ Creating embedding for text: \"${text.slice(0, 50)}...\"`);\n        const response = await fetch(\"https://api.openai.com/v1/embeddings\", {\n            method: \"POST\",\n            headers: {\n                \"Authorization\": `Bearer ${OPENAI_API_KEY}`,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                model: \"text-embedding-ada-002\",\n                input: text.trim()\n            })\n        });\n        log(`OpenAI response status: ${response.status}`);\n        if (!response.ok) {\n            const errorBody = await response.text();\n            log(`‚ùå OpenAI API error ${response.status}:`, errorBody);\n            return undefined;\n        }\n        const data = await response.json();\n        if (!data.data || !data.data[0] || !data.data[0].embedding) {\n            log(\"‚ùå Invalid embedding response structure:\", data);\n            return undefined;\n        }\n        log(\"‚úÖ Embedding created successfully\");\n        return data.data[0].embedding;\n    } catch (error) {\n        log(\"‚ùå Embedding request failed:\", error);\n        return undefined;\n    }\n}\n// --- ENHANCED CHUNKING ---\n// Create smart chunks that preserve context and speaker boundaries\nfunction createSmartChunks(content, episodeName) {\n    const chunks = [];\n    // Split by natural boundaries (paragraphs, speaker changes)\n    const sections = content.split(/\\n\\s*\\n|\\n(?=[A-Z][a-z]*:)/).filter((s)=>s.trim().length > 50);\n    let chunkIndex = 0;\n    for(let i = 0; i < sections.length; i++){\n        const section = sections[i].trim();\n        // If section is too long, split smartly\n        if (section.length > 800) {\n            const sentences = section.split(/[.!?]+/).filter((s)=>s.trim().length > 20);\n            let currentChunk = \"\";\n            for (const sentence of sentences){\n                if ((currentChunk + sentence).length > 600) {\n                    if (currentChunk.trim()) {\n                        chunks.push(createChunkWithMetadata(currentChunk.trim(), episodeName, chunkIndex++, {\n                            prevContext: i > 0 ? sections[i - 1].slice(-100) : \"\",\n                            nextContext: i < sections.length - 1 ? sections[i + 1].slice(0, 100) : \"\"\n                        }));\n                    }\n                    currentChunk = sentence;\n                } else {\n                    currentChunk += sentence + \". \";\n                }\n            }\n            if (currentChunk.trim()) {\n                chunks.push(createChunkWithMetadata(currentChunk.trim(), episodeName, chunkIndex++, {\n                    prevContext: i > 0 ? sections[i - 1].slice(-100) : \"\",\n                    nextContext: i < sections.length - 1 ? sections[i + 1].slice(0, 100) : \"\"\n                }));\n            }\n        } else {\n            // Section is good size, keep as-is\n            chunks.push(createChunkWithMetadata(section, episodeName, chunkIndex++, {\n                prevContext: i > 0 ? sections[i - 1].slice(-100) : \"\",\n                nextContext: i < sections.length - 1 ? sections[i + 1].slice(0, 100) : \"\"\n            }));\n        }\n    }\n    return chunks;\n}\n// Create chunk with enhanced metadata\nfunction createChunkWithMetadata(text, episodeName, index, context) {\n    // Extract speaker information\n    const speakerMatch = text.match(/^([A-Z][a-z\\s]+):\\s*(.+)/);\n    let speaker = \"unknown\";\n    let guestName;\n    let cleanText = text;\n    if (speakerMatch) {\n        const speakerName = speakerMatch[1].toLowerCase();\n        cleanText = speakerMatch[2];\n        if (speakerName.includes(\"nikhil\") || speakerName.includes(\"host\")) {\n            speaker = \"host\";\n        } else {\n            speaker = \"guest\";\n            guestName = speakerMatch[1];\n        }\n    }\n    // Extract topics using enhanced keyword detection\n    const topics = extractTopics(cleanText + \" \" + context.prevContext + \" \" + context.nextContext);\n    // Extract timestamp if present\n    const timestampMatch = text.match(/\\[(\\d{1,2}:\\d{2}(?::\\d{2})?)\\]/);\n    const timestamp = timestampMatch ? timestampMatch[1] : undefined;\n    return {\n        text: cleanText,\n        episode: episodeName,\n        episodeTitle: formatEpisodeTitle(episodeName),\n        speaker,\n        guestName,\n        timestamp,\n        topics,\n        index,\n        context: context.prevContext + \" [...] \" + context.nextContext\n    };\n}\n// Enhanced topic extraction\nfunction extractTopics(text) {\n    const topicPatterns = {\n        \"real-estate\": /real estate|property|housing|construction|builder|apartment|rent/gi,\n        \"gaming\": /game|gaming|esports|mobile gaming|pc gaming|console|developer/gi,\n        \"startup\": /startup|entrepreneur|business|company|venture|founder/gi,\n        \"fintech\": /fintech|financial|banking|payment|wallet|upi|digital payment/gi,\n        \"edtech\": /education|learning|online course|skill|training|edtech/gi,\n        \"food\": /restaurant|food|dining|kitchen|chef|delivery|zomato|swiggy/gi,\n        \"ev\": /electric vehicle|ev|battery|automotive|car|vehicle|charging/gi,\n        \"investment\": /investment|funding|vc|investor|capital|valuation|ipo/gi,\n        \"marketing\": /marketing|brand|advertising|content|social media|influencer/gi,\n        \"healthcare\": /healthcare|medical|hospital|doctor|telemedicine|pharma/gi\n    };\n    const detectedTopics = [];\n    Object.entries(topicPatterns).forEach(([topic, pattern])=>{\n        if (pattern.test(text)) {\n            detectedTopics.push(topic);\n        }\n    });\n    return detectedTopics;\n}\nfunction formatEpisodeTitle(episodeName) {\n    return episodeName.replace(/[-_]/g, \" \").replace(/\\b\\w/g, (l)=>l.toUpperCase());\n}\n// --- ORIGINAL SYSTEM (IMPROVED) ---\n// Initialize the system - load and embed transcripts\nasync function initialize() {\n    if (isReady || initError) return;\n    try {\n        log(\"\\uD83D\\uDE80 Initializing transcript system...\");\n        // Find transcript files\n        const transcriptPath = path__WEBPACK_IMPORTED_MODULE_1___default().join(process.cwd(), \"public\", \"transcripts\");\n        log(`Looking for transcripts in: ${transcriptPath}`);\n        let files = [];\n        try {\n            files = await fs__WEBPACK_IMPORTED_MODULE_0__.promises.readdir(transcriptPath);\n            files = files.filter((f)=>f.endsWith(\".txt\"));\n        } catch (error) {\n            initError = `Cannot access transcript directory: ${transcriptPath}`;\n            log(initError);\n            return;\n        }\n        if (files.length === 0) {\n            initError = \"No .txt transcript files found\";\n            log(initError);\n            return;\n        }\n        log(`Found ${files.length} transcript files`);\n        // Process each transcript file\n        let totalChunks = 0;\n        for (const filename of files){\n            try {\n                const filePath = path__WEBPACK_IMPORTED_MODULE_1___default().join(transcriptPath, filename);\n                const content = await fs__WEBPACK_IMPORTED_MODULE_0__.promises.readFile(filePath, \"utf-8\");\n                const episodeName = filename.replace(\".txt\", \"\");\n                if (content.trim().length < 100) {\n                    log(`Skipping ${filename} - too short`);\n                    continue;\n                }\n                // Split into chunks of ~500 characters\n                const chunkSize = 500;\n                let chunkIndex = 0;\n                for(let i = 0; i < content.length; i += chunkSize){\n                    const chunkText = content.slice(i, i + chunkSize).trim();\n                    if (chunkText.length > 50) {\n                        chunks.push({\n                            text: chunkText,\n                            episode: filename.replace(\".txt\", \"\"),\n                            index: chunkIndex++\n                        });\n                        totalChunks++;\n                    }\n                }\n                log(`Processed ${filename}: ${chunkIndex} chunks`);\n            } catch (error) {\n                log(`Error reading ${filename}:`, error);\n            }\n        }\n        if (totalChunks === 0) {\n            initError = \"No valid content chunks created from transcripts\";\n            log(initError);\n            return;\n        }\n        log(`üìÑ Created ${totalChunks} total chunks`);\n        // Create embeddings with better error handling\n        const chunksToEmbed = chunks.slice(0, 50) // Limit to first 50 chunks for testing\n        ;\n        log(`üîÑ Creating embeddings for ${chunksToEmbed.length} chunks...`);\n        let embeddedCount = 0;\n        let consecutiveFailures = 0;\n        for(let i = 0; i < chunksToEmbed.length; i++){\n            const chunk = chunksToEmbed[i];\n            if (i % 5 === 0) {\n                log(`Embedding progress: ${i + 1}/${chunksToEmbed.length} (${embeddedCount} successful)`);\n            }\n            const embedding = await getEmbedding(chunk.text);\n            if (embedding) {\n                chunk.embedding = embedding;\n                embeddedCount++;\n                consecutiveFailures = 0;\n            } else {\n                consecutiveFailures++;\n                if (consecutiveFailures >= 5) {\n                    log(\"‚ùå Too many consecutive embedding failures, stopping\");\n                    break;\n                }\n            }\n            await new Promise((resolve)=>setTimeout(resolve, 500));\n        }\n        log(`‚úÖ Successfully embedded ${embeddedCount}/${chunksToEmbed.length} chunks`);\n        isReady = true;\n        log(\"\\uD83C\\uDF89 System ready!\");\n    } catch (error) {\n        initError = `Initialization failed: ${error}`;\n        log(initError);\n    }\n}\n// Enhanced keyword search with better relevance\nfunction searchByKeywordsEnhanced(query) {\n    const queryWords = query.toLowerCase().split(/\\s+/).filter((word)=>word.length > 2);\n    if (queryWords.length === 0) return [];\n    const results = chunks.map((chunk)=>{\n        const text = chunk.text.toLowerCase();\n        let score = 0;\n        let matchedWords = 0;\n        queryWords.forEach((word)=>{\n            const matches = (text.match(new RegExp(word, \"g\")) || []).length;\n            if (matches > 0) {\n                score += matches;\n                matchedWords++;\n            }\n        });\n        if (text.includes(query.toLowerCase())) {\n            score += 5;\n        }\n        const coverage = matchedWords / queryWords.length;\n        if (coverage < 0.3) {\n            score *= 0.5;\n        }\n        return {\n            chunk,\n            score\n        };\n    }).filter((result)=>result.score > 0.5).sort((a, b)=>b.score - a.score).slice(0, 3);\n    return results.map((r)=>r.chunk);\n}\n// Enhanced search with better query understanding\nasync function findRelevantChunks(query) {\n    await initialize();\n    if (!isReady) {\n        log(\"‚ùå System not ready\");\n        return [];\n    }\n    // First try semantic search with embeddings\n    const queryEmbedding = await getEmbedding(query);\n    if (queryEmbedding) {\n        log(\"\\uD83C\\uDFAF Using semantic search\");\n        const withEmbeddings = chunks.filter((chunk)=>chunk.embedding);\n        if (withEmbeddings.length > 0) {\n            const results = withEmbeddings.map((chunk)=>({\n                    chunk,\n                    score: similarity(queryEmbedding, chunk.embedding)\n                })).filter((result)=>result.score > 0.2).sort((a, b)=>b.score - a.score).slice(0, 3);\n            if (results.length > 0) {\n                log(`‚úÖ Found ${results.length} semantic matches`);\n                return results.map((r)=>r.chunk);\n            }\n        }\n    }\n    // Fallback to enhanced keyword search\n    log(\"‚ö†Ô∏è Falling back to enhanced keyword search\");\n    return searchByKeywordsEnhanced(query);\n}\n// Call Groq API to generate response\nasync function generateWithGroq(messages) {\n    if (!GROQ_API_KEY) {\n        return \"Error: GROQ_API_KEY not configured\";\n    }\n    log(\"Calling Groq API...\");\n    try {\n        const response = await fetch(\"https://api.groq.com/openai/v1/chat/completions\", {\n            method: \"POST\",\n            headers: {\n                \"Authorization\": `Bearer ${GROQ_API_KEY}`,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                model: \"llama3-8b-8192\",\n                messages: messages,\n                max_tokens: 800,\n                temperature: 0.2 // Lower temperature for less hallucination\n            })\n        });\n        log(`Groq response status: ${response.status}`);\n        if (!response.ok) {\n            const errorText = await response.text();\n            log(\"Groq error:\", errorText);\n            return `Groq API error (${response.status})`;\n        }\n        const data = await response.json();\n        const content = data.choices?.[0]?.message?.content;\n        if (!content) {\n            log(\"No content in Groq response\");\n            return \"No response generated\";\n        }\n        log(`Generated response (${content.length} chars)`);\n        return content.trim();\n    } catch (error) {\n        log(\"Groq request failed:\", error);\n        return `Request failed: ${error}`;\n    }\n}\n// --- ENHANCED SYSTEM ---\n// Initialize enhanced system\nasync function initializeEnhanced() {\n    if (isEnhancedReady) return;\n    log(\"\\uD83D\\uDE80 Initializing enhanced system...\");\n    try {\n        const transcriptPath = path__WEBPACK_IMPORTED_MODULE_1___default().join(process.cwd(), \"public\", \"transcripts\");\n        const files = await fs__WEBPACK_IMPORTED_MODULE_0__.promises.readdir(transcriptPath);\n        const txtFiles = files.filter((f)=>f.endsWith(\".txt\"));\n        for (const filename of txtFiles){\n            const filePath = path__WEBPACK_IMPORTED_MODULE_1___default().join(transcriptPath, filename);\n            const content = await fs__WEBPACK_IMPORTED_MODULE_0__.promises.readFile(filePath, \"utf-8\");\n            const episodeName = filename.replace(\".txt\", \"\");\n            const chunks = createSmartChunks(content, episodeName);\n            enhancedChunks.push(...chunks);\n            log(`Processed ${filename}: ${chunks.length} smart chunks`);\n        }\n        // Create embeddings for a subset (for testing)\n        const chunksToEmbed = enhancedChunks.slice(0, 30);\n        for (const chunk of chunksToEmbed){\n            const embedding = await getEmbedding(chunk.text);\n            if (embedding) {\n                chunk.embedding = embedding;\n            }\n            await new Promise((resolve)=>setTimeout(resolve, 500)) // Rate limit\n            ;\n        }\n        isEnhancedReady = true;\n        log(`‚úÖ Enhanced system ready with ${enhancedChunks.length} chunks`);\n    } catch (error) {\n        log(\"Enhanced initialization failed:\", error);\n    }\n}\n// Multi-stage retrieval for enhanced system\nasync function performMultiStageRetrieval(query) {\n    const results = [];\n    // Stage 1: Topic-based filtering\n    const queryTopics = extractTopics(query);\n    const topicFilteredChunks = queryTopics.length > 0 ? enhancedChunks.filter((chunk)=>chunk.topics.some((topic)=>queryTopics.includes(topic))) : enhancedChunks;\n    log(`Stage 1: Filtered to ${topicFilteredChunks.length} chunks by topics: ${queryTopics.join(\", \")}`);\n    // Stage 2: Semantic similarity (if embeddings available)\n    const queryEmbedding = await getEmbedding(query);\n    let semanticCandidates = [];\n    if (queryEmbedding) {\n        const semanticResults = topicFilteredChunks.filter((chunk)=>chunk.embedding).map((chunk)=>({\n                chunk,\n                similarity: cosineSimilarity(queryEmbedding, chunk.embedding || [])\n            })).filter((result)=>result.similarity > 0.25).sort((a, b)=>b.similarity - a.similarity).slice(0, 10);\n        semanticCandidates = semanticResults.map((r)=>r.chunk);\n        log(`Stage 2: Found ${semanticCandidates.length} semantic matches`);\n    }\n    // Stage 3: Enhanced keyword matching\n    const keywordCandidates = enhancedKeywordSearch(query, topicFilteredChunks);\n    // Stage 4: Combine and re-rank results\n    const combinedCandidates = [\n        ...semanticCandidates,\n        ...keywordCandidates\n    ];\n    const uniqueCandidatesMap = new Map();\n    combinedCandidates.forEach((chunk)=>{\n        const key = `${chunk.episode}-${chunk.index}`;\n        if (!uniqueCandidatesMap.has(key)) {\n            uniqueCandidatesMap.set(key, chunk);\n        }\n    });\n    const allCandidates = Array.from(uniqueCandidatesMap.values());\n    for (const chunk of allCandidates){\n        const relevanceScore = calculateEnhancedRelevance(query, chunk, queryEmbedding || undefined);\n        const confidenceLevel = determineConfidenceLevel(relevanceScore, chunk, query);\n        const matchReason = explainMatch(query, chunk, relevanceScore);\n        if (relevanceScore > 0.3) {\n            results.push({\n                chunk,\n                relevanceScore,\n                confidenceLevel,\n                matchReason\n            });\n        }\n    }\n    return results.sort((a, b)=>b.relevanceScore - a.relevanceScore).slice(0, 5);\n}\nfunction enhancedKeywordSearch(query, chunks) {\n    const queryWords = query.toLowerCase().split(/\\s+/).filter((word)=>word.length > 2);\n    return chunks.map((chunk)=>({\n            chunk,\n            score: calculateKeywordRelevance(query, chunk.text + \" \" + chunk.context)\n        })).filter((result)=>result.score > 0.3).sort((a, b)=>b.score - a.score).slice(0, 8).map((r)=>r.chunk);\n}\nfunction calculateKeywordRelevance(query, text) {\n    const queryWords = query.toLowerCase().split(/\\s+/).filter((word)=>word.length > 2);\n    const textLower = text.toLowerCase();\n    let score = 0;\n    queryWords.forEach((word)=>{\n        const matches = (textLower.match(new RegExp(word, \"g\")) || []).length;\n        score += matches * (word.length / 10);\n    });\n    if (textLower.includes(query.toLowerCase())) {\n        score += 2;\n    }\n    return Math.min(score / (queryWords.length * 2), 1);\n}\nfunction calculateEnhancedRelevance(query, chunk, queryEmbedding) {\n    let score = 0;\n    // Semantic similarity (40% weight)\n    if (queryEmbedding && chunk.embedding) {\n        const semanticScore = cosineSimilarity(queryEmbedding, chunk.embedding);\n        score += semanticScore * 0.4;\n    }\n    // Keyword relevance (30% weight)\n    const keywordScore = calculateKeywordRelevance(query, chunk.text);\n    score += keywordScore * 0.3;\n    // Topic alignment (20% weight)\n    const queryTopics = extractTopics(query);\n    const topicOverlap = chunk.topics.filter((topic)=>queryTopics.includes(topic)).length;\n    const topicScore = queryTopics.length > 0 ? topicOverlap / queryTopics.length : 0.5;\n    score += topicScore * 0.2;\n    // Context relevance (10% weight)\n    const contextScore = calculateKeywordRelevance(query, chunk.context);\n    score += contextScore * 0.1;\n    return Math.min(score, 1);\n}\nfunction determineConfidenceLevel(score, chunk, query) {\n    if (score > 0.7 && chunk.topics.length > 0) {\n        const queryTopics = extractTopics(query);\n        if (queryTopics.some((topic)=>chunk.topics.includes(topic))) {\n            return \"high\";\n        }\n    }\n    if (score > 0.5) {\n        return \"medium\";\n    }\n    return \"low\";\n}\nfunction explainMatch(query, chunk, score) {\n    const reasons = [];\n    if (chunk.topics.length > 0) {\n        const queryTopics = extractTopics(query);\n        const matchingTopics = chunk.topics.filter((topic)=>queryTopics.includes(topic));\n        if (matchingTopics.length > 0) {\n            reasons.push(`Topic match: ${matchingTopics.join(\", \")}`);\n        }\n    }\n    const keywordMatches = findKeywordMatches(query, chunk.text);\n    if (keywordMatches.length > 0) {\n        reasons.push(`Keywords: ${keywordMatches.slice(0, 3).join(\", \")}`);\n    }\n    if (score > 0.7) {\n        reasons.push(\"High semantic similarity\");\n    }\n    return reasons.length > 0 ? reasons.join(\"; \") : \"General relevance\";\n}\nfunction findKeywordMatches(query, text) {\n    const queryWords = query.toLowerCase().split(/\\s+/).filter((word)=>word.length > 2);\n    const textLower = text.toLowerCase();\n    return queryWords.filter((word)=>textLower.includes(word));\n}\n// Improved prompt for cleaner, more professional responses\nfunction createCleanResponsePrompt(results) {\n    const highConfidenceResults = results.filter((r)=>r.confidenceLevel === \"high\");\n    const mediumConfidenceResults = results.filter((r)=>r.confidenceLevel === \"medium\");\n    return `You are a professional podcast analyst. Provide clean, well-structured responses based strictly on the provided transcript content.\n\n**RESPONSE STRUCTURE:**\n1. Start with a clear, direct answer to the question\n2. Provide key insights with specific details from the episodes\n3. Include relevant episode sources naturally in the text\n4. End with actionable takeaways when applicable\n\n**FORMATTING RULES:**\n- Write in natural, flowing prose - NO asterisks, bullet points, or formatting markers\n- NO section headers like \"Direct Answer\" or \"Key Insights\" \n- Integrate source citations naturally (e.g., \"According to the episode with [Guest Name]...\")\n- Use confident, professional language\n- Keep paragraphs focused and readable\n\n**CONTENT GUIDELINES:**\n- Only use information directly from the provided transcripts\n- Cite specific episodes and speakers naturally in your response\n- If information is limited, acknowledge this briefly without being apologetic\n- Focus on practical, actionable insights when possible\n- Distinguish between high-confidence (${highConfidenceResults.length} sources) and medium-confidence (${mediumConfidenceResults.length} sources) information when relevant\n\n**TONE:**\n- Professional but conversational\n- Confident and authoritative\n- Helpful and informative\n- No unnecessary qualifiers or hedging\n\nWrite your response as if you're a knowledgeable consultant sharing insights from the podcast content.`;\n}\nfunction getAvailableTopics() {\n    const allTopicsSet = new Set();\n    enhancedChunks.forEach((chunk)=>{\n        chunk.topics.forEach((topic)=>allTopicsSet.add(topic));\n    });\n    return Array.from(allTopicsSet).slice(0, 10);\n}\n// Clean response formatting helper\nfunction cleanResponse(response) {\n    // Remove markdown-style formatting\n    let cleaned = response// Remove bold/italic markers\n    .replace(/\\*\\*([^*]+)\\*\\*/g, \"$1\").replace(/\\*([^*]+)\\*/g, \"$1\")// Remove section headers that look like \"**Direct Answer:**\"\n    .replace(/\\*\\*[^*]+\\*\\*:\\s*/g, \"\")// Remove bullet points and convert to flowing text\n    .replace(/^\\s*[-‚Ä¢]\\s*/gm, \"\")// Remove numbered lists formatting\n    .replace(/^\\s*\\d+\\.\\s*/gm, \"\")// Clean up extra whitespace\n    .replace(/\\n\\s*\\n\\s*\\n/g, \"\\n\\n\").replace(/^\\s+|\\s+$/g, \"\");\n    return cleaned;\n}\n// --- PUBLIC API ---\n// Main function to generate response (improved with better formatting)\nasync function generateResponse(query) {\n    log(\"=== NEW QUERY ===\");\n    log(`Query: \"${query}\"`);\n    if (!query?.trim()) {\n        return \"Please ask me a question about the podcast!\";\n    }\n    if (!GROQ_API_KEY) {\n        return \"‚ö†Ô∏è GROQ_API_KEY environment variable not set\";\n    }\n    if (!OPENAI_API_KEY) {\n        return \"‚ö†Ô∏è OPENAI_API_KEY environment variable not set\";\n    }\n    try {\n        const relevantChunks = await findRelevantChunks(query);\n        if (relevantChunks.length === 0) {\n            if (initError) {\n                return `System error: ${initError}`;\n            }\n            return `I don't have relevant information about \"${query}\" in the available episodes. Try asking about topics that were specifically discussed in the podcast.`;\n        }\n        const context = relevantChunks.map((chunk, i)=>`Episode: ${chunk.episode}\n${chunk.text}`).join(\"\\n\\n---\\n\\n\");\n        const messages = [\n            {\n                role: \"system\",\n                content: `You are a professional podcast analyst who provides insightful, well-structured responses. \n\n**RESPONSE GUIDELINES:**\n- Write in natural, flowing prose without any formatting markers (**, *, bullets, etc.)\n- Start directly with your answer - no section headers or labels\n- Integrate episode citations naturally into your response\n- Focus on actionable insights and practical value\n- Use confident, professional language\n- Keep responses conversational but authoritative\n\n**CONTENT RULES:**\n- Only use information from the provided transcript content\n- When referencing content, mention the episode naturally (e.g., \"In the episode about...\")\n- If information is limited, briefly acknowledge this without being apologetic\n- Provide strategic analysis, not just summary\n- Connect insights to practical implications when possible\n\nWrite your response as if you're a knowledgeable consultant sharing insights from the podcast episodes. No formatting markers, section headers, or bullet points - just clean, professional prose.`\n            },\n            {\n                role: \"user\",\n                content: `Podcast content:\\n\\n${context}\\n\\nQuestion: ${query}\\n\\nProvide a clear, insightful response based on this content. Write in natural prose without any formatting markers or section headers.`\n            }\n        ];\n        const response = await generateWithGroq(messages);\n        const cleanedResponse = cleanResponse(response);\n        log(\"Response generated and cleaned successfully\");\n        return cleanedResponse;\n    } catch (error) {\n        log(\"Error in generateResponse:\", error);\n        return `Something went wrong: ${error}`;\n    }\n}\n// Enhanced response generation with improved formatting\nasync function generateEnhancedResponse(query) {\n    log(\"=== ENHANCED QUERY PROCESSING ===\");\n    log(`Query: \"${query}\"`);\n    try {\n        await initializeEnhanced();\n        if (!isEnhancedReady) {\n            return \"Enhanced system not ready. Please check transcript files and API keys.\";\n        }\n        const results = await performMultiStageRetrieval(query);\n        if (results.length === 0) {\n            return `I don't have specific information about \"${query}\" in the available podcast episodes. Try asking about topics that were explicitly discussed, such as: ${getAvailableTopics().join(\", \")}.`;\n        }\n        const context = results.map((result, i)=>{\n            return `Episode: ${result.chunk.episodeTitle}\n${result.chunk.speaker === \"guest\" && result.chunk.guestName ? `Speaker: ${result.chunk.guestName}` : `Speaker: ${result.chunk.speaker}`}\n${result.chunk.timestamp ? `Time: ${result.chunk.timestamp}` : \"\"}\nConfidence: ${result.confidenceLevel}\n\nContent: ${result.chunk.text}`;\n        }).join(\"\\n\\n---\\n\\n\");\n        const messages = [\n            {\n                role: \"system\",\n                content: createCleanResponsePrompt(results)\n            },\n            {\n                role: \"user\",\n                content: `TRANSCRIPT CONTENT:\\n\\n${context}\\n\\nQUESTION: ${query}\\n\\nProvide a professional response using only the information above. Write in clean, natural prose without formatting markers, section headers, or bullet points.`\n            }\n        ];\n        const response = await generateWithGroq(messages);\n        const cleanedResponse = cleanResponse(response);\n        log(\"Enhanced response generated and cleaned successfully\");\n        return cleanedResponse;\n    } catch (error) {\n        log(\"Error in enhanced generation:\", error);\n        return `I encountered an error processing your question. Please try again.`;\n    }\n}\n// Simple fallback function\nfunction getQuickResponse(query) {\n    if (query) {\n        return `I'm having trouble processing your question about \"${query}\". Please try again or ask something else about the podcast!`;\n    }\n    return \"Hi! Ask me about the podcast and I'll search through the available transcripts.\";\n}\n// System status check\nasync function getSystemStatus() {\n    await initialize();\n    const status = {\n        ready: isReady,\n        enhancedReady: isEnhancedReady,\n        error: initError,\n        totalChunks: chunks.length,\n        enhancedChunks: enhancedChunks.length,\n        embeddedChunks: chunks.filter((c)=>c.embedding).length,\n        enhancedEmbeddedChunks: enhancedChunks.filter((c)=>c.embedding).length,\n        hasGroqKey: !!GROQ_API_KEY,\n        hasOpenAIKey: !!OPENAI_API_KEY,\n        availableTopics: isEnhancedReady ? getAvailableTopics() : []\n    };\n    return JSON.stringify(status, null, 2);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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T0s7UUFDUHVGLGFBQWEzRixPQUFPYSxNQUFNO1FBQzFCWixnQkFBZ0JBLGVBQWVZLE1BQU07UUFDckMwSyxnQkFBZ0J2TCxPQUFPNEMsTUFBTSxDQUFDNEksQ0FBQUEsSUFBS0EsRUFBRWxKLFNBQVMsRUFBRXpCLE1BQU07UUFDdEQ0Syx3QkFBd0J4TCxlQUFlMkMsTUFBTSxDQUFDNEksQ0FBQUEsSUFBS0EsRUFBRWxKLFNBQVMsRUFBRXpCLE1BQU07UUFDdEU2SyxZQUFZLENBQUMsQ0FBQ2hNO1FBQ2RpTSxjQUFjLENBQUMsQ0FBQzlMO1FBQ2hCK0wsaUJBQWlCekwsa0JBQWtCcUssdUJBQXVCLEVBQUU7SUFDOUQ7SUFFQSxPQUFPaEssS0FBS0MsU0FBUyxDQUFDeUIsUUFBUSxNQUFNO0FBQ3RDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd3RmLXBvZGNhc3QvLi9zcmMvbGliL2FpLnRzP2RhMjkiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gbGliL2FpLnRzXG4vLyBFbmhhbmNlZCBwb2RjYXN0IFEmQSBzeXN0ZW0gd2l0aCBpbXByb3ZlZCByZXNwb25zZSBmb3JtYXR0aW5nXG5cbmltcG9ydCB7IHByb21pc2VzIGFzIGZzIH0gZnJvbSAnZnMnXG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJ1xuXG4vLyAtLS0gQ09ORklHVVJBVElPTiAtLS1cbmNvbnN0IEdST1FfQVBJX0tFWSA9IHByb2Nlc3MuZW52LkdST1FfQVBJX0tFWVxuY29uc3QgT1BFTkFJX0FQSV9LRVkgPSBwcm9jZXNzLmVudi5PUEVOQUlfQVBJX0tFWVxuXG5pZiAoIUdST1FfQVBJX0tFWSkge1xuICBjb25zb2xlLmVycm9yKCfinYwgR1JPUV9BUElfS0VZIGVudmlyb25tZW50IHZhcmlhYmxlIGlzIHJlcXVpcmVkJylcbn1cbmlmICghT1BFTkFJX0FQSV9LRVkpIHtcbiAgY29uc29sZS5lcnJvcign4p2MIE9QRU5BSV9BUElfS0VZIGVudmlyb25tZW50IHZhcmlhYmxlIGlzIHJlcXVpcmVkJylcbn1cblxuLy8gLS0tIFRZUEVTIC0tLVxuaW50ZXJmYWNlIENodW5rIHtcbiAgdGV4dDogc3RyaW5nXG4gIGVwaXNvZGU6IHN0cmluZ1xuICBpbmRleDogbnVtYmVyXG4gIGVtYmVkZGluZz86IG51bWJlcltdXG59XG5cbmludGVyZmFjZSBFbmhhbmNlZENodW5rIHtcbiAgdGV4dDogc3RyaW5nXG4gIGVwaXNvZGU6IHN0cmluZ1xuICBlcGlzb2RlVGl0bGU6IHN0cmluZ1xuICBzcGVha2VyPzogJ2hvc3QnIHwgJ2d1ZXN0JyB8ICd1bmtub3duJ1xuICBndWVzdE5hbWU/OiBzdHJpbmdcbiAgdGltZXN0YW1wPzogc3RyaW5nXG4gIHRvcGljczogc3RyaW5nW11cbiAgaW5kZXg6IG51bWJlclxuICBlbWJlZGRpbmc/OiBudW1iZXJbXVxuICBjb250ZXh0OiBzdHJpbmdcbn1cblxuaW50ZXJmYWNlIENoYXRNZXNzYWdlIHtcbiAgcm9sZTogJ3N5c3RlbScgfCAndXNlcicgfCAnYXNzaXN0YW50J1xuICBjb250ZW50OiBzdHJpbmdcbn1cblxuaW50ZXJmYWNlIFJldHJpZXZhbFJlc3VsdCB7XG4gIGNodW5rOiBFbmhhbmNlZENodW5rXG4gIHJlbGV2YW5jZVNjb3JlOiBudW1iZXJcbiAgY29uZmlkZW5jZUxldmVsOiAnaGlnaCcgfCAnbWVkaXVtJyB8ICdsb3cnXG4gIG1hdGNoUmVhc29uOiBzdHJpbmdcbn1cblxuLy8gLS0tIEdMT0JBTCBTVEFURSAtLS1cbmxldCBjaHVua3M6IENodW5rW10gPSBbXVxubGV0IGVuaGFuY2VkQ2h1bmtzOiBFbmhhbmNlZENodW5rW10gPSBbXVxubGV0IGlzUmVhZHkgPSBmYWxzZVxubGV0IGlzRW5oYW5jZWRSZWFkeSA9IGZhbHNlXG5sZXQgaW5pdEVycm9yOiBzdHJpbmcgfCBudWxsID0gbnVsbFxuXG4vLyAtLS0gSEVMUEVSIEZVTkNUSU9OUyAtLS1cbmZ1bmN0aW9uIGxvZyhtZXNzYWdlOiBzdHJpbmcsIGRhdGE/OiBhbnkpIHtcbiAgY29uc29sZS5sb2coYFtBSV0gJHttZXNzYWdlfWAsIGRhdGEgPyBKU09OLnN0cmluZ2lmeShkYXRhLCBudWxsLCAyKSA6ICcnKVxufVxuXG4vLyBDYWxjdWxhdGUgc2ltaWxhcml0eSBiZXR3ZWVuIHR3byB2ZWN0b3JzXG5mdW5jdGlvbiBzaW1pbGFyaXR5KGE6IG51bWJlcltdLCBiOiBudW1iZXJbXSk6IG51bWJlciB7XG4gIGlmICghYSB8fCAhYiB8fCBhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiAwXG4gIFxuICBsZXQgZG90ID0gMCwgbWFnQSA9IDAsIG1hZ0IgPSAwXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgIGRvdCArPSBhW2ldICogYltpXVxuICAgIG1hZ0EgKz0gYVtpXSAqIGFbaV1cbiAgICBtYWdCICs9IGJbaV0gKiBiW2ldXG4gIH1cbiAgXG4gIGNvbnN0IG1hZ25pdHVkZSA9IE1hdGguc3FydChtYWdBICogbWFnQilcbiAgcmV0dXJuIG1hZ25pdHVkZSA+IDAgPyBkb3QgLyBtYWduaXR1ZGUgOiAwXG59XG5cbi8vIEVuaGFuY2VkIGNvc2luZSBzaW1pbGFyaXR5IChoYW5kbGVzIHVuZGVmaW5lZClcbmZ1bmN0aW9uIGNvc2luZVNpbWlsYXJpdHkoYTogbnVtYmVyW10sIGI6IG51bWJlcltdKTogbnVtYmVyIHtcbiAgaWYgKCFhIHx8ICFiIHx8IGEubGVuZ3RoICE9PSBiLmxlbmd0aCB8fCBhLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcbiAgXG4gIGxldCBkb3QgPSAwLCBtYWdBID0gMCwgbWFnQiA9IDBcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgZG90ICs9IGFbaV0gKiBiW2ldXG4gICAgbWFnQSArPSBhW2ldICogYVtpXVxuICAgIG1hZ0IgKz0gYltpXSAqIGJbaV1cbiAgfVxuICBcbiAgY29uc3QgbWFnbml0dWRlID0gTWF0aC5zcXJ0KG1hZ0EgKiBtYWdCKVxuICByZXR1cm4gbWFnbml0dWRlID4gMCA/IGRvdCAvIG1hZ25pdHVkZSA6IDBcbn1cblxuLy8gR2V0IGVtYmVkZGluZyBmcm9tIE9wZW5BSSB3aXRoIGRldGFpbGVkIGVycm9yIGhhbmRsaW5nXG5hc3luYyBmdW5jdGlvbiBnZXRFbWJlZGRpbmcodGV4dDogc3RyaW5nKTogUHJvbWlzZTxudW1iZXJbXSB8IHVuZGVmaW5lZD4ge1xuICBpZiAoIU9QRU5BSV9BUElfS0VZKSB7XG4gICAgbG9nKCfinYwgTm8gT3BlbkFJIEFQSSBrZXkgcHJvdmlkZWQnKVxuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuICBcbiAgaWYgKCF0ZXh0LnRyaW0oKSB8fCB0ZXh0LnRyaW0oKS5sZW5ndGggPCAxMCkge1xuICAgIGxvZygn4p2MIFRleHQgdG9vIHNob3J0IGZvciBlbWJlZGRpbmcnKVxuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuICBcbiAgdHJ5IHtcbiAgICBsb2coYPCflIQgQ3JlYXRpbmcgZW1iZWRkaW5nIGZvciB0ZXh0OiBcIiR7dGV4dC5zbGljZSgwLCA1MCl9Li4uXCJgKVxuICAgIFxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJ2h0dHBzOi8vYXBpLm9wZW5haS5jb20vdjEvZW1iZWRkaW5ncycsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHtPUEVOQUlfQVBJX0tFWX1gLFxuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBtb2RlbDogJ3RleHQtZW1iZWRkaW5nLWFkYS0wMDInLFxuICAgICAgICBpbnB1dDogdGV4dC50cmltKClcbiAgICAgIH0pXG4gICAgfSlcbiAgICBcbiAgICBsb2coYE9wZW5BSSByZXNwb25zZSBzdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgY29uc3QgZXJyb3JCb2R5ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpXG4gICAgICBsb2coYOKdjCBPcGVuQUkgQVBJIGVycm9yICR7cmVzcG9uc2Uuc3RhdHVzfTpgLCBlcnJvckJvZHkpXG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICBcbiAgICBpZiAoIWRhdGEuZGF0YSB8fCAhZGF0YS5kYXRhWzBdIHx8ICFkYXRhLmRhdGFbMF0uZW1iZWRkaW5nKSB7XG4gICAgICBsb2coJ+KdjCBJbnZhbGlkIGVtYmVkZGluZyByZXNwb25zZSBzdHJ1Y3R1cmU6JywgZGF0YSlcbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG4gICAgXG4gICAgbG9nKCfinIUgRW1iZWRkaW5nIGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5JylcbiAgICByZXR1cm4gZGF0YS5kYXRhWzBdLmVtYmVkZGluZ1xuICAgIFxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGxvZygn4p2MIEVtYmVkZGluZyByZXF1ZXN0IGZhaWxlZDonLCBlcnJvcilcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cbn1cblxuLy8gLS0tIEVOSEFOQ0VEIENIVU5LSU5HIC0tLVxuXG4vLyBDcmVhdGUgc21hcnQgY2h1bmtzIHRoYXQgcHJlc2VydmUgY29udGV4dCBhbmQgc3BlYWtlciBib3VuZGFyaWVzXG5mdW5jdGlvbiBjcmVhdGVTbWFydENodW5rcyhjb250ZW50OiBzdHJpbmcsIGVwaXNvZGVOYW1lOiBzdHJpbmcpOiBFbmhhbmNlZENodW5rW10ge1xuICBjb25zdCBjaHVua3M6IEVuaGFuY2VkQ2h1bmtbXSA9IFtdXG4gIFxuICAvLyBTcGxpdCBieSBuYXR1cmFsIGJvdW5kYXJpZXMgKHBhcmFncmFwaHMsIHNwZWFrZXIgY2hhbmdlcylcbiAgY29uc3Qgc2VjdGlvbnMgPSBjb250ZW50LnNwbGl0KC9cXG5cXHMqXFxufFxcbig/PVtBLVpdW2Etel0qOikvKS5maWx0ZXIocyA9PiBzLnRyaW0oKS5sZW5ndGggPiA1MClcbiAgXG4gIGxldCBjaHVua0luZGV4ID0gMFxuICBcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNlY3Rpb24gPSBzZWN0aW9uc1tpXS50cmltKClcbiAgICBcbiAgICAvLyBJZiBzZWN0aW9uIGlzIHRvbyBsb25nLCBzcGxpdCBzbWFydGx5XG4gICAgaWYgKHNlY3Rpb24ubGVuZ3RoID4gODAwKSB7XG4gICAgICBjb25zdCBzZW50ZW5jZXMgPSBzZWN0aW9uLnNwbGl0KC9bLiE/XSsvKS5maWx0ZXIocyA9PiBzLnRyaW0oKS5sZW5ndGggPiAyMClcbiAgICAgIGxldCBjdXJyZW50Q2h1bmsgPSAnJ1xuICAgICAgXG4gICAgICBmb3IgKGNvbnN0IHNlbnRlbmNlIG9mIHNlbnRlbmNlcykge1xuICAgICAgICBpZiAoKGN1cnJlbnRDaHVuayArIHNlbnRlbmNlKS5sZW5ndGggPiA2MDApIHtcbiAgICAgICAgICBpZiAoY3VycmVudENodW5rLnRyaW0oKSkge1xuICAgICAgICAgICAgY2h1bmtzLnB1c2goY3JlYXRlQ2h1bmtXaXRoTWV0YWRhdGEoY3VycmVudENodW5rLnRyaW0oKSwgZXBpc29kZU5hbWUsIGNodW5rSW5kZXgrKywge1xuICAgICAgICAgICAgICBwcmV2Q29udGV4dDogaSA+IDAgPyBzZWN0aW9uc1tpLTFdLnNsaWNlKC0xMDApIDogJycsXG4gICAgICAgICAgICAgIG5leHRDb250ZXh0OiBpIDwgc2VjdGlvbnMubGVuZ3RoIC0gMSA/IHNlY3Rpb25zW2krMV0uc2xpY2UoMCwgMTAwKSA6ICcnXG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICB9XG4gICAgICAgICAgY3VycmVudENodW5rID0gc2VudGVuY2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50Q2h1bmsgKz0gc2VudGVuY2UgKyAnLiAnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKGN1cnJlbnRDaHVuay50cmltKCkpIHtcbiAgICAgICAgY2h1bmtzLnB1c2goY3JlYXRlQ2h1bmtXaXRoTWV0YWRhdGEoY3VycmVudENodW5rLnRyaW0oKSwgZXBpc29kZU5hbWUsIGNodW5rSW5kZXgrKywge1xuICAgICAgICAgIHByZXZDb250ZXh0OiBpID4gMCA/IHNlY3Rpb25zW2ktMV0uc2xpY2UoLTEwMCkgOiAnJyxcbiAgICAgICAgICBuZXh0Q29udGV4dDogaSA8IHNlY3Rpb25zLmxlbmd0aCAtIDEgPyBzZWN0aW9uc1tpKzFdLnNsaWNlKDAsIDEwMCkgOiAnJ1xuICAgICAgICB9KSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2VjdGlvbiBpcyBnb29kIHNpemUsIGtlZXAgYXMtaXNcbiAgICAgIGNodW5rcy5wdXNoKGNyZWF0ZUNodW5rV2l0aE1ldGFkYXRhKHNlY3Rpb24sIGVwaXNvZGVOYW1lLCBjaHVua0luZGV4KyssIHtcbiAgICAgICAgcHJldkNvbnRleHQ6IGkgPiAwID8gc2VjdGlvbnNbaS0xXS5zbGljZSgtMTAwKSA6ICcnLFxuICAgICAgICBuZXh0Q29udGV4dDogaSA8IHNlY3Rpb25zLmxlbmd0aCAtIDEgPyBzZWN0aW9uc1tpKzFdLnNsaWNlKDAsIDEwMCkgOiAnJ1xuICAgICAgfSkpXG4gICAgfVxuICB9XG4gIFxuICByZXR1cm4gY2h1bmtzXG59XG5cbi8vIENyZWF0ZSBjaHVuayB3aXRoIGVuaGFuY2VkIG1ldGFkYXRhXG5mdW5jdGlvbiBjcmVhdGVDaHVua1dpdGhNZXRhZGF0YShcbiAgdGV4dDogc3RyaW5nLCBcbiAgZXBpc29kZU5hbWU6IHN0cmluZywgXG4gIGluZGV4OiBudW1iZXIsIFxuICBjb250ZXh0OiB7IHByZXZDb250ZXh0OiBzdHJpbmcsIG5leHRDb250ZXh0OiBzdHJpbmcgfVxuKTogRW5oYW5jZWRDaHVuayB7XG4gIFxuICAvLyBFeHRyYWN0IHNwZWFrZXIgaW5mb3JtYXRpb25cbiAgY29uc3Qgc3BlYWtlck1hdGNoID0gdGV4dC5tYXRjaCgvXihbQS1aXVthLXpcXHNdKyk6XFxzKiguKykvKVxuICBsZXQgc3BlYWtlcjogJ2hvc3QnIHwgJ2d1ZXN0JyB8ICd1bmtub3duJyA9ICd1bmtub3duJ1xuICBsZXQgZ3Vlc3ROYW1lOiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgbGV0IGNsZWFuVGV4dCA9IHRleHRcbiAgXG4gIGlmIChzcGVha2VyTWF0Y2gpIHtcbiAgICBjb25zdCBzcGVha2VyTmFtZSA9IHNwZWFrZXJNYXRjaFsxXS50b0xvd2VyQ2FzZSgpXG4gICAgY2xlYW5UZXh0ID0gc3BlYWtlck1hdGNoWzJdXG4gICAgXG4gICAgaWYgKHNwZWFrZXJOYW1lLmluY2x1ZGVzKCduaWtoaWwnKSB8fCBzcGVha2VyTmFtZS5pbmNsdWRlcygnaG9zdCcpKSB7XG4gICAgICBzcGVha2VyID0gJ2hvc3QnXG4gICAgfSBlbHNlIHtcbiAgICAgIHNwZWFrZXIgPSAnZ3Vlc3QnXG4gICAgICBndWVzdE5hbWUgPSBzcGVha2VyTWF0Y2hbMV1cbiAgICB9XG4gIH1cbiAgXG4gIC8vIEV4dHJhY3QgdG9waWNzIHVzaW5nIGVuaGFuY2VkIGtleXdvcmQgZGV0ZWN0aW9uXG4gIGNvbnN0IHRvcGljcyA9IGV4dHJhY3RUb3BpY3MoY2xlYW5UZXh0ICsgJyAnICsgY29udGV4dC5wcmV2Q29udGV4dCArICcgJyArIGNvbnRleHQubmV4dENvbnRleHQpXG4gIFxuICAvLyBFeHRyYWN0IHRpbWVzdGFtcCBpZiBwcmVzZW50XG4gIGNvbnN0IHRpbWVzdGFtcE1hdGNoID0gdGV4dC5tYXRjaCgvXFxbKFxcZHsxLDJ9OlxcZHsyfSg/OjpcXGR7Mn0pPylcXF0vKVxuICBjb25zdCB0aW1lc3RhbXAgPSB0aW1lc3RhbXBNYXRjaCA/IHRpbWVzdGFtcE1hdGNoWzFdIDogdW5kZWZpbmVkXG4gIFxuICByZXR1cm4ge1xuICAgIHRleHQ6IGNsZWFuVGV4dCxcbiAgICBlcGlzb2RlOiBlcGlzb2RlTmFtZSxcbiAgICBlcGlzb2RlVGl0bGU6IGZvcm1hdEVwaXNvZGVUaXRsZShlcGlzb2RlTmFtZSksXG4gICAgc3BlYWtlcixcbiAgICBndWVzdE5hbWUsXG4gICAgdGltZXN0YW1wLFxuICAgIHRvcGljcyxcbiAgICBpbmRleCxcbiAgICBjb250ZXh0OiBjb250ZXh0LnByZXZDb250ZXh0ICsgJyBbLi4uXSAnICsgY29udGV4dC5uZXh0Q29udGV4dFxuICB9XG59XG5cbi8vIEVuaGFuY2VkIHRvcGljIGV4dHJhY3Rpb25cbmZ1bmN0aW9uIGV4dHJhY3RUb3BpY3ModGV4dDogc3RyaW5nKTogc3RyaW5nW10ge1xuICBjb25zdCB0b3BpY1BhdHRlcm5zID0ge1xuICAgICdyZWFsLWVzdGF0ZSc6IC9yZWFsIGVzdGF0ZXxwcm9wZXJ0eXxob3VzaW5nfGNvbnN0cnVjdGlvbnxidWlsZGVyfGFwYXJ0bWVudHxyZW50L2dpLFxuICAgICdnYW1pbmcnOiAvZ2FtZXxnYW1pbmd8ZXNwb3J0c3xtb2JpbGUgZ2FtaW5nfHBjIGdhbWluZ3xjb25zb2xlfGRldmVsb3Blci9naSxcbiAgICAnc3RhcnR1cCc6IC9zdGFydHVwfGVudHJlcHJlbmV1cnxidXNpbmVzc3xjb21wYW55fHZlbnR1cmV8Zm91bmRlci9naSxcbiAgICAnZmludGVjaCc6IC9maW50ZWNofGZpbmFuY2lhbHxiYW5raW5nfHBheW1lbnR8d2FsbGV0fHVwaXxkaWdpdGFsIHBheW1lbnQvZ2ksXG4gICAgJ2VkdGVjaCc6IC9lZHVjYXRpb258bGVhcm5pbmd8b25saW5lIGNvdXJzZXxza2lsbHx0cmFpbmluZ3xlZHRlY2gvZ2ksXG4gICAgJ2Zvb2QnOiAvcmVzdGF1cmFudHxmb29kfGRpbmluZ3xraXRjaGVufGNoZWZ8ZGVsaXZlcnl8em9tYXRvfHN3aWdneS9naSxcbiAgICAnZXYnOiAvZWxlY3RyaWMgdmVoaWNsZXxldnxiYXR0ZXJ5fGF1dG9tb3RpdmV8Y2FyfHZlaGljbGV8Y2hhcmdpbmcvZ2ksXG4gICAgJ2ludmVzdG1lbnQnOiAvaW52ZXN0bWVudHxmdW5kaW5nfHZjfGludmVzdG9yfGNhcGl0YWx8dmFsdWF0aW9ufGlwby9naSxcbiAgICAnbWFya2V0aW5nJzogL21hcmtldGluZ3xicmFuZHxhZHZlcnRpc2luZ3xjb250ZW50fHNvY2lhbCBtZWRpYXxpbmZsdWVuY2VyL2dpLFxuICAgICdoZWFsdGhjYXJlJzogL2hlYWx0aGNhcmV8bWVkaWNhbHxob3NwaXRhbHxkb2N0b3J8dGVsZW1lZGljaW5lfHBoYXJtYS9naVxuICB9XG4gIFxuICBjb25zdCBkZXRlY3RlZFRvcGljczogc3RyaW5nW10gPSBbXVxuICBcbiAgT2JqZWN0LmVudHJpZXModG9waWNQYXR0ZXJucykuZm9yRWFjaCgoW3RvcGljLCBwYXR0ZXJuXSkgPT4ge1xuICAgIGlmIChwYXR0ZXJuLnRlc3QodGV4dCkpIHtcbiAgICAgIGRldGVjdGVkVG9waWNzLnB1c2godG9waWMpXG4gICAgfVxuICB9KVxuICBcbiAgcmV0dXJuIGRldGVjdGVkVG9waWNzXG59XG5cbmZ1bmN0aW9uIGZvcm1hdEVwaXNvZGVUaXRsZShlcGlzb2RlTmFtZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIGVwaXNvZGVOYW1lLnJlcGxhY2UoL1stX10vZywgJyAnKS5yZXBsYWNlKC9cXGJcXHcvZywgbCA9PiBsLnRvVXBwZXJDYXNlKCkpXG59XG5cbi8vIC0tLSBPUklHSU5BTCBTWVNURU0gKElNUFJPVkVEKSAtLS1cblxuLy8gSW5pdGlhbGl6ZSB0aGUgc3lzdGVtIC0gbG9hZCBhbmQgZW1iZWQgdHJhbnNjcmlwdHNcbmFzeW5jIGZ1bmN0aW9uIGluaXRpYWxpemUoKTogUHJvbWlzZTx2b2lkPiB7XG4gIGlmIChpc1JlYWR5IHx8IGluaXRFcnJvcikgcmV0dXJuXG4gIFxuICB0cnkge1xuICAgIGxvZygn8J+agCBJbml0aWFsaXppbmcgdHJhbnNjcmlwdCBzeXN0ZW0uLi4nKVxuICAgIFxuICAgIC8vIEZpbmQgdHJhbnNjcmlwdCBmaWxlc1xuICAgIGNvbnN0IHRyYW5zY3JpcHRQYXRoID0gcGF0aC5qb2luKHByb2Nlc3MuY3dkKCksICdwdWJsaWMnLCAndHJhbnNjcmlwdHMnKVxuICAgIGxvZyhgTG9va2luZyBmb3IgdHJhbnNjcmlwdHMgaW46ICR7dHJhbnNjcmlwdFBhdGh9YClcbiAgICBcbiAgICBsZXQgZmlsZXM6IHN0cmluZ1tdID0gW11cbiAgICB0cnkge1xuICAgICAgZmlsZXMgPSBhd2FpdCBmcy5yZWFkZGlyKHRyYW5zY3JpcHRQYXRoKVxuICAgICAgZmlsZXMgPSBmaWxlcy5maWx0ZXIoZiA9PiBmLmVuZHNXaXRoKCcudHh0JykpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGluaXRFcnJvciA9IGBDYW5ub3QgYWNjZXNzIHRyYW5zY3JpcHQgZGlyZWN0b3J5OiAke3RyYW5zY3JpcHRQYXRofWBcbiAgICAgIGxvZyhpbml0RXJyb3IpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgXG4gICAgaWYgKGZpbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaW5pdEVycm9yID0gJ05vIC50eHQgdHJhbnNjcmlwdCBmaWxlcyBmb3VuZCdcbiAgICAgIGxvZyhpbml0RXJyb3IpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgXG4gICAgbG9nKGBGb3VuZCAke2ZpbGVzLmxlbmd0aH0gdHJhbnNjcmlwdCBmaWxlc2ApXG4gICAgXG4gICAgLy8gUHJvY2VzcyBlYWNoIHRyYW5zY3JpcHQgZmlsZVxuICAgIGxldCB0b3RhbENodW5rcyA9IDBcbiAgICBmb3IgKGNvbnN0IGZpbGVuYW1lIG9mIGZpbGVzKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBmaWxlUGF0aCA9IHBhdGguam9pbih0cmFuc2NyaXB0UGF0aCwgZmlsZW5hbWUpXG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCBmcy5yZWFkRmlsZShmaWxlUGF0aCwgJ3V0Zi04JylcbiAgICAgICAgY29uc3QgZXBpc29kZU5hbWUgPSBmaWxlbmFtZS5yZXBsYWNlKCcudHh0JywgJycpXG4gICAgICAgIFxuICAgICAgICBpZiAoY29udGVudC50cmltKCkubGVuZ3RoIDwgMTAwKSB7XG4gICAgICAgICAgbG9nKGBTa2lwcGluZyAke2ZpbGVuYW1lfSAtIHRvbyBzaG9ydGApXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gU3BsaXQgaW50byBjaHVua3Mgb2YgfjUwMCBjaGFyYWN0ZXJzXG4gICAgICAgIGNvbnN0IGNodW5rU2l6ZSA9IDUwMFxuICAgICAgICBsZXQgY2h1bmtJbmRleCA9IDBcbiAgICAgICAgXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29udGVudC5sZW5ndGg7IGkgKz0gY2h1bmtTaXplKSB7XG4gICAgICAgICAgY29uc3QgY2h1bmtUZXh0ID0gY29udGVudC5zbGljZShpLCBpICsgY2h1bmtTaXplKS50cmltKClcbiAgICAgICAgICBpZiAoY2h1bmtUZXh0Lmxlbmd0aCA+IDUwKSB7XG4gICAgICAgICAgICBjaHVua3MucHVzaCh7XG4gICAgICAgICAgICAgIHRleHQ6IGNodW5rVGV4dCxcbiAgICAgICAgICAgICAgZXBpc29kZTogZmlsZW5hbWUucmVwbGFjZSgnLnR4dCcsICcnKSxcbiAgICAgICAgICAgICAgaW5kZXg6IGNodW5rSW5kZXgrK1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHRvdGFsQ2h1bmtzKytcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGxvZyhgUHJvY2Vzc2VkICR7ZmlsZW5hbWV9OiAke2NodW5rSW5kZXh9IGNodW5rc2ApXG4gICAgICAgIFxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nKGBFcnJvciByZWFkaW5nICR7ZmlsZW5hbWV9OmAsIGVycm9yKVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBpZiAodG90YWxDaHVua3MgPT09IDApIHtcbiAgICAgIGluaXRFcnJvciA9ICdObyB2YWxpZCBjb250ZW50IGNodW5rcyBjcmVhdGVkIGZyb20gdHJhbnNjcmlwdHMnXG4gICAgICBsb2coaW5pdEVycm9yKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIFxuICAgIGxvZyhg8J+ThCBDcmVhdGVkICR7dG90YWxDaHVua3N9IHRvdGFsIGNodW5rc2ApXG4gICAgXG4gICAgLy8gQ3JlYXRlIGVtYmVkZGluZ3Mgd2l0aCBiZXR0ZXIgZXJyb3IgaGFuZGxpbmdcbiAgICBjb25zdCBjaHVua3NUb0VtYmVkID0gY2h1bmtzLnNsaWNlKDAsIDUwKSAvLyBMaW1pdCB0byBmaXJzdCA1MCBjaHVua3MgZm9yIHRlc3RpbmdcbiAgICBsb2coYPCflIQgQ3JlYXRpbmcgZW1iZWRkaW5ncyBmb3IgJHtjaHVua3NUb0VtYmVkLmxlbmd0aH0gY2h1bmtzLi4uYClcbiAgICBcbiAgICBsZXQgZW1iZWRkZWRDb3VudCA9IDBcbiAgICBsZXQgY29uc2VjdXRpdmVGYWlsdXJlcyA9IDBcbiAgICBcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNodW5rc1RvRW1iZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNodW5rID0gY2h1bmtzVG9FbWJlZFtpXVxuICAgICAgXG4gICAgICBpZiAoaSAlIDUgPT09IDApIHtcbiAgICAgICAgbG9nKGBFbWJlZGRpbmcgcHJvZ3Jlc3M6ICR7aSArIDF9LyR7Y2h1bmtzVG9FbWJlZC5sZW5ndGh9ICgke2VtYmVkZGVkQ291bnR9IHN1Y2Nlc3NmdWwpYClcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgZW1iZWRkaW5nID0gYXdhaXQgZ2V0RW1iZWRkaW5nKGNodW5rLnRleHQpXG4gICAgICBpZiAoZW1iZWRkaW5nKSB7XG4gICAgICAgIGNodW5rLmVtYmVkZGluZyA9IGVtYmVkZGluZ1xuICAgICAgICBlbWJlZGRlZENvdW50KytcbiAgICAgICAgY29uc2VjdXRpdmVGYWlsdXJlcyA9IDBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNlY3V0aXZlRmFpbHVyZXMrK1xuICAgICAgICBcbiAgICAgICAgaWYgKGNvbnNlY3V0aXZlRmFpbHVyZXMgPj0gNSkge1xuICAgICAgICAgIGxvZygn4p2MIFRvbyBtYW55IGNvbnNlY3V0aXZlIGVtYmVkZGluZyBmYWlsdXJlcywgc3RvcHBpbmcnKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpXG4gICAgfVxuICAgIFxuICAgIGxvZyhg4pyFIFN1Y2Nlc3NmdWxseSBlbWJlZGRlZCAke2VtYmVkZGVkQ291bnR9LyR7Y2h1bmtzVG9FbWJlZC5sZW5ndGh9IGNodW5rc2ApXG4gICAgXG4gICAgaXNSZWFkeSA9IHRydWVcbiAgICBsb2coJ/CfjokgU3lzdGVtIHJlYWR5IScpXG4gICAgXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaW5pdEVycm9yID0gYEluaXRpYWxpemF0aW9uIGZhaWxlZDogJHtlcnJvcn1gXG4gICAgbG9nKGluaXRFcnJvcilcbiAgfVxufVxuXG4vLyBFbmhhbmNlZCBrZXl3b3JkIHNlYXJjaCB3aXRoIGJldHRlciByZWxldmFuY2VcbmZ1bmN0aW9uIHNlYXJjaEJ5S2V5d29yZHNFbmhhbmNlZChxdWVyeTogc3RyaW5nKTogQ2h1bmtbXSB7XG4gIGNvbnN0IHF1ZXJ5V29yZHMgPSBxdWVyeS50b0xvd2VyQ2FzZSgpXG4gICAgLnNwbGl0KC9cXHMrLylcbiAgICAuZmlsdGVyKHdvcmQgPT4gd29yZC5sZW5ndGggPiAyKVxuICBcbiAgaWYgKHF1ZXJ5V29yZHMubGVuZ3RoID09PSAwKSByZXR1cm4gW11cbiAgXG4gIGNvbnN0IHJlc3VsdHMgPSBjaHVua3NcbiAgICAubWFwKGNodW5rID0+IHtcbiAgICAgIGNvbnN0IHRleHQgPSBjaHVuay50ZXh0LnRvTG93ZXJDYXNlKClcbiAgICAgIGxldCBzY29yZSA9IDBcbiAgICAgIGxldCBtYXRjaGVkV29yZHMgPSAwXG4gICAgICBcbiAgICAgIHF1ZXJ5V29yZHMuZm9yRWFjaCh3b3JkID0+IHtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9ICh0ZXh0Lm1hdGNoKG5ldyBSZWdFeHAod29yZCwgJ2cnKSkgfHwgW10pLmxlbmd0aFxuICAgICAgICBpZiAobWF0Y2hlcyA+IDApIHtcbiAgICAgICAgICBzY29yZSArPSBtYXRjaGVzXG4gICAgICAgICAgbWF0Y2hlZFdvcmRzKytcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIFxuICAgICAgaWYgKHRleHQuaW5jbHVkZXMocXVlcnkudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgc2NvcmUgKz0gNVxuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBjb3ZlcmFnZSA9IG1hdGNoZWRXb3JkcyAvIHF1ZXJ5V29yZHMubGVuZ3RoXG4gICAgICBpZiAoY292ZXJhZ2UgPCAwLjMpIHtcbiAgICAgICAgc2NvcmUgKj0gMC41XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiB7IGNodW5rLCBzY29yZSB9XG4gICAgfSlcbiAgICAuZmlsdGVyKHJlc3VsdCA9PiByZXN1bHQuc2NvcmUgPiAwLjUpXG4gICAgLnNvcnQoKGEsIGIpID0+IGIuc2NvcmUgLSBhLnNjb3JlKVxuICAgIC5zbGljZSgwLCAzKVxuICBcbiAgcmV0dXJuIHJlc3VsdHMubWFwKHIgPT4gci5jaHVuaylcbn1cblxuLy8gRW5oYW5jZWQgc2VhcmNoIHdpdGggYmV0dGVyIHF1ZXJ5IHVuZGVyc3RhbmRpbmdcbmFzeW5jIGZ1bmN0aW9uIGZpbmRSZWxldmFudENodW5rcyhxdWVyeTogc3RyaW5nKTogUHJvbWlzZTxDaHVua1tdPiB7XG4gIGF3YWl0IGluaXRpYWxpemUoKVxuICBcbiAgaWYgKCFpc1JlYWR5KSB7XG4gICAgbG9nKCfinYwgU3lzdGVtIG5vdCByZWFkeScpXG4gICAgcmV0dXJuIFtdXG4gIH1cbiAgXG4gIC8vIEZpcnN0IHRyeSBzZW1hbnRpYyBzZWFyY2ggd2l0aCBlbWJlZGRpbmdzXG4gIGNvbnN0IHF1ZXJ5RW1iZWRkaW5nID0gYXdhaXQgZ2V0RW1iZWRkaW5nKHF1ZXJ5KVxuICBcbiAgaWYgKHF1ZXJ5RW1iZWRkaW5nKSB7XG4gICAgbG9nKCfwn46vIFVzaW5nIHNlbWFudGljIHNlYXJjaCcpXG4gICAgXG4gICAgY29uc3Qgd2l0aEVtYmVkZGluZ3MgPSBjaHVua3MuZmlsdGVyKGNodW5rID0+IGNodW5rLmVtYmVkZGluZylcbiAgICBcbiAgICBpZiAod2l0aEVtYmVkZGluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgcmVzdWx0cyA9IHdpdGhFbWJlZGRpbmdzXG4gICAgICAgIC5tYXAoY2h1bmsgPT4gKHtcbiAgICAgICAgICBjaHVuayxcbiAgICAgICAgICBzY29yZTogc2ltaWxhcml0eShxdWVyeUVtYmVkZGluZywgY2h1bmsuZW1iZWRkaW5nISlcbiAgICAgICAgfSkpXG4gICAgICAgIC5maWx0ZXIocmVzdWx0ID0+IHJlc3VsdC5zY29yZSA+IDAuMilcbiAgICAgICAgLnNvcnQoKGEsIGIpID0+IGIuc2NvcmUgLSBhLnNjb3JlKVxuICAgICAgICAuc2xpY2UoMCwgMylcbiAgICAgIFxuICAgICAgaWYgKHJlc3VsdHMubGVuZ3RoID4gMCkge1xuICAgICAgICBsb2coYOKchSBGb3VuZCAke3Jlc3VsdHMubGVuZ3RofSBzZW1hbnRpYyBtYXRjaGVzYClcbiAgICAgICAgcmV0dXJuIHJlc3VsdHMubWFwKHIgPT4gci5jaHVuaylcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgXG4gIC8vIEZhbGxiYWNrIHRvIGVuaGFuY2VkIGtleXdvcmQgc2VhcmNoXG4gIGxvZygn4pqg77iPIEZhbGxpbmcgYmFjayB0byBlbmhhbmNlZCBrZXl3b3JkIHNlYXJjaCcpXG4gIHJldHVybiBzZWFyY2hCeUtleXdvcmRzRW5oYW5jZWQocXVlcnkpXG59XG5cbi8vIENhbGwgR3JvcSBBUEkgdG8gZ2VuZXJhdGUgcmVzcG9uc2VcbmFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlV2l0aEdyb3EobWVzc2FnZXM6IENoYXRNZXNzYWdlW10pOiBQcm9taXNlPHN0cmluZz4ge1xuICBpZiAoIUdST1FfQVBJX0tFWSkge1xuICAgIHJldHVybiAnRXJyb3I6IEdST1FfQVBJX0tFWSBub3QgY29uZmlndXJlZCdcbiAgfVxuICBcbiAgbG9nKCdDYWxsaW5nIEdyb3EgQVBJLi4uJylcbiAgXG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnaHR0cHM6Ly9hcGkuZ3JvcS5jb20vb3BlbmFpL3YxL2NoYXQvY29tcGxldGlvbnMnLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7R1JPUV9BUElfS0VZfWAsXG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIG1vZGVsOiAnbGxhbWEzLThiLTgxOTInLFxuICAgICAgICBtZXNzYWdlczogbWVzc2FnZXMsXG4gICAgICAgIG1heF90b2tlbnM6IDgwMCxcbiAgICAgICAgdGVtcGVyYXR1cmU6IDAuMiAvLyBMb3dlciB0ZW1wZXJhdHVyZSBmb3IgbGVzcyBoYWxsdWNpbmF0aW9uXG4gICAgICB9KVxuICAgIH0pXG4gICAgXG4gICAgbG9nKGBHcm9xIHJlc3BvbnNlIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICBcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCBlcnJvclRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KClcbiAgICAgIGxvZygnR3JvcSBlcnJvcjonLCBlcnJvclRleHQpXG4gICAgICByZXR1cm4gYEdyb3EgQVBJIGVycm9yICgke3Jlc3BvbnNlLnN0YXR1c30pYFxuICAgIH1cbiAgICBcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gICAgY29uc3QgY29udGVudCA9IGRhdGEuY2hvaWNlcz8uWzBdPy5tZXNzYWdlPy5jb250ZW50XG4gICAgXG4gICAgaWYgKCFjb250ZW50KSB7XG4gICAgICBsb2coJ05vIGNvbnRlbnQgaW4gR3JvcSByZXNwb25zZScpXG4gICAgICByZXR1cm4gJ05vIHJlc3BvbnNlIGdlbmVyYXRlZCdcbiAgICB9XG4gICAgXG4gICAgbG9nKGBHZW5lcmF0ZWQgcmVzcG9uc2UgKCR7Y29udGVudC5sZW5ndGh9IGNoYXJzKWApXG4gICAgcmV0dXJuIGNvbnRlbnQudHJpbSgpXG4gICAgXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgbG9nKCdHcm9xIHJlcXVlc3QgZmFpbGVkOicsIGVycm9yKVxuICAgIHJldHVybiBgUmVxdWVzdCBmYWlsZWQ6ICR7ZXJyb3J9YFxuICB9XG59XG5cbi8vIC0tLSBFTkhBTkNFRCBTWVNURU0gLS0tXG5cbi8vIEluaXRpYWxpemUgZW5oYW5jZWQgc3lzdGVtXG5hc3luYyBmdW5jdGlvbiBpbml0aWFsaXplRW5oYW5jZWQoKTogUHJvbWlzZTx2b2lkPiB7XG4gIGlmIChpc0VuaGFuY2VkUmVhZHkpIHJldHVyblxuICBcbiAgbG9nKCfwn5qAIEluaXRpYWxpemluZyBlbmhhbmNlZCBzeXN0ZW0uLi4nKVxuICBcbiAgdHJ5IHtcbiAgICBjb25zdCB0cmFuc2NyaXB0UGF0aCA9IHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAncHVibGljJywgJ3RyYW5zY3JpcHRzJylcbiAgICBjb25zdCBmaWxlcyA9IGF3YWl0IGZzLnJlYWRkaXIodHJhbnNjcmlwdFBhdGgpXG4gICAgY29uc3QgdHh0RmlsZXMgPSBmaWxlcy5maWx0ZXIoZiA9PiBmLmVuZHNXaXRoKCcudHh0JykpXG4gICAgXG4gICAgZm9yIChjb25zdCBmaWxlbmFtZSBvZiB0eHRGaWxlcykge1xuICAgICAgY29uc3QgZmlsZVBhdGggPSBwYXRoLmpvaW4odHJhbnNjcmlwdFBhdGgsIGZpbGVuYW1lKVxuICAgICAgY29uc3QgY29udGVudCA9IGF3YWl0IGZzLnJlYWRGaWxlKGZpbGVQYXRoLCAndXRmLTgnKVxuICAgICAgY29uc3QgZXBpc29kZU5hbWUgPSBmaWxlbmFtZS5yZXBsYWNlKCcudHh0JywgJycpXG4gICAgICBcbiAgICAgIGNvbnN0IGNodW5rcyA9IGNyZWF0ZVNtYXJ0Q2h1bmtzKGNvbnRlbnQsIGVwaXNvZGVOYW1lKVxuICAgICAgZW5oYW5jZWRDaHVua3MucHVzaCguLi5jaHVua3MpXG4gICAgICBcbiAgICAgIGxvZyhgUHJvY2Vzc2VkICR7ZmlsZW5hbWV9OiAke2NodW5rcy5sZW5ndGh9IHNtYXJ0IGNodW5rc2ApXG4gICAgfVxuICAgIFxuICAgIC8vIENyZWF0ZSBlbWJlZGRpbmdzIGZvciBhIHN1YnNldCAoZm9yIHRlc3RpbmcpXG4gICAgY29uc3QgY2h1bmtzVG9FbWJlZCA9IGVuaGFuY2VkQ2h1bmtzLnNsaWNlKDAsIDMwKVxuICAgIGZvciAoY29uc3QgY2h1bmsgb2YgY2h1bmtzVG9FbWJlZCkge1xuICAgICAgY29uc3QgZW1iZWRkaW5nID0gYXdhaXQgZ2V0RW1iZWRkaW5nKGNodW5rLnRleHQpXG4gICAgICBpZiAoZW1iZWRkaW5nKSB7XG4gICAgICAgIGNodW5rLmVtYmVkZGluZyA9IGVtYmVkZGluZ1xuICAgICAgfVxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpIC8vIFJhdGUgbGltaXRcbiAgICB9XG4gICAgXG4gICAgaXNFbmhhbmNlZFJlYWR5ID0gdHJ1ZVxuICAgIGxvZyhg4pyFIEVuaGFuY2VkIHN5c3RlbSByZWFkeSB3aXRoICR7ZW5oYW5jZWRDaHVua3MubGVuZ3RofSBjaHVua3NgKVxuICAgIFxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGxvZygnRW5oYW5jZWQgaW5pdGlhbGl6YXRpb24gZmFpbGVkOicsIGVycm9yKVxuICB9XG59XG5cbi8vIE11bHRpLXN0YWdlIHJldHJpZXZhbCBmb3IgZW5oYW5jZWQgc3lzdGVtXG5hc3luYyBmdW5jdGlvbiBwZXJmb3JtTXVsdGlTdGFnZVJldHJpZXZhbChxdWVyeTogc3RyaW5nKTogUHJvbWlzZTxSZXRyaWV2YWxSZXN1bHRbXT4ge1xuICBjb25zdCByZXN1bHRzOiBSZXRyaWV2YWxSZXN1bHRbXSA9IFtdXG4gIFxuICAvLyBTdGFnZSAxOiBUb3BpYy1iYXNlZCBmaWx0ZXJpbmdcbiAgY29uc3QgcXVlcnlUb3BpY3MgPSBleHRyYWN0VG9waWNzKHF1ZXJ5KVxuICBjb25zdCB0b3BpY0ZpbHRlcmVkQ2h1bmtzID0gcXVlcnlUb3BpY3MubGVuZ3RoID4gMCBcbiAgICA/IGVuaGFuY2VkQ2h1bmtzLmZpbHRlcihjaHVuayA9PiBcbiAgICAgICAgY2h1bmsudG9waWNzLnNvbWUodG9waWMgPT4gcXVlcnlUb3BpY3MuaW5jbHVkZXModG9waWMpKVxuICAgICAgKVxuICAgIDogZW5oYW5jZWRDaHVua3NcbiAgXG4gIGxvZyhgU3RhZ2UgMTogRmlsdGVyZWQgdG8gJHt0b3BpY0ZpbHRlcmVkQ2h1bmtzLmxlbmd0aH0gY2h1bmtzIGJ5IHRvcGljczogJHtxdWVyeVRvcGljcy5qb2luKCcsICcpfWApXG4gIFxuICAvLyBTdGFnZSAyOiBTZW1hbnRpYyBzaW1pbGFyaXR5IChpZiBlbWJlZGRpbmdzIGF2YWlsYWJsZSlcbiAgY29uc3QgcXVlcnlFbWJlZGRpbmcgPSBhd2FpdCBnZXRFbWJlZGRpbmcocXVlcnkpXG4gIGxldCBzZW1hbnRpY0NhbmRpZGF0ZXM6IEVuaGFuY2VkQ2h1bmtbXSA9IFtdXG4gIFxuICBpZiAocXVlcnlFbWJlZGRpbmcpIHtcbiAgICBjb25zdCBzZW1hbnRpY1Jlc3VsdHMgPSB0b3BpY0ZpbHRlcmVkQ2h1bmtzXG4gICAgICAuZmlsdGVyKGNodW5rID0+IGNodW5rLmVtYmVkZGluZylcbiAgICAgIC5tYXAoY2h1bmsgPT4gKHtcbiAgICAgICAgY2h1bmssXG4gICAgICAgIHNpbWlsYXJpdHk6IGNvc2luZVNpbWlsYXJpdHkocXVlcnlFbWJlZGRpbmcsIGNodW5rLmVtYmVkZGluZyB8fCBbXSlcbiAgICAgIH0pKVxuICAgICAgLmZpbHRlcihyZXN1bHQgPT4gcmVzdWx0LnNpbWlsYXJpdHkgPiAwLjI1KVxuICAgICAgLnNvcnQoKGEsIGIpID0+IGIuc2ltaWxhcml0eSAtIGEuc2ltaWxhcml0eSlcbiAgICAgIC5zbGljZSgwLCAxMClcbiAgICBcbiAgICBzZW1hbnRpY0NhbmRpZGF0ZXMgPSBzZW1hbnRpY1Jlc3VsdHMubWFwKHIgPT4gci5jaHVuaylcbiAgICBsb2coYFN0YWdlIDI6IEZvdW5kICR7c2VtYW50aWNDYW5kaWRhdGVzLmxlbmd0aH0gc2VtYW50aWMgbWF0Y2hlc2ApXG4gIH1cbiAgXG4gIC8vIFN0YWdlIDM6IEVuaGFuY2VkIGtleXdvcmQgbWF0Y2hpbmdcbiAgY29uc3Qga2V5d29yZENhbmRpZGF0ZXMgPSBlbmhhbmNlZEtleXdvcmRTZWFyY2gocXVlcnksIHRvcGljRmlsdGVyZWRDaHVua3MpXG4gIFxuICAvLyBTdGFnZSA0OiBDb21iaW5lIGFuZCByZS1yYW5rIHJlc3VsdHNcbiAgY29uc3QgY29tYmluZWRDYW5kaWRhdGVzID0gWy4uLnNlbWFudGljQ2FuZGlkYXRlcywgLi4ua2V5d29yZENhbmRpZGF0ZXNdXG4gIGNvbnN0IHVuaXF1ZUNhbmRpZGF0ZXNNYXAgPSBuZXcgTWFwPHN0cmluZywgRW5oYW5jZWRDaHVuaz4oKVxuICBcbiAgY29tYmluZWRDYW5kaWRhdGVzLmZvckVhY2goY2h1bmsgPT4ge1xuICAgIGNvbnN0IGtleSA9IGAke2NodW5rLmVwaXNvZGV9LSR7Y2h1bmsuaW5kZXh9YFxuICAgIGlmICghdW5pcXVlQ2FuZGlkYXRlc01hcC5oYXMoa2V5KSkge1xuICAgICAgdW5pcXVlQ2FuZGlkYXRlc01hcC5zZXQoa2V5LCBjaHVuaylcbiAgICB9XG4gIH0pXG4gIFxuICBjb25zdCBhbGxDYW5kaWRhdGVzID0gQXJyYXkuZnJvbSh1bmlxdWVDYW5kaWRhdGVzTWFwLnZhbHVlcygpKVxuICBcbiAgZm9yIChjb25zdCBjaHVuayBvZiBhbGxDYW5kaWRhdGVzKSB7XG4gICAgY29uc3QgcmVsZXZhbmNlU2NvcmUgPSBjYWxjdWxhdGVFbmhhbmNlZFJlbGV2YW5jZShxdWVyeSwgY2h1bmssIHF1ZXJ5RW1iZWRkaW5nIHx8IHVuZGVmaW5lZClcbiAgICBjb25zdCBjb25maWRlbmNlTGV2ZWwgPSBkZXRlcm1pbmVDb25maWRlbmNlTGV2ZWwocmVsZXZhbmNlU2NvcmUsIGNodW5rLCBxdWVyeSlcbiAgICBjb25zdCBtYXRjaFJlYXNvbiA9IGV4cGxhaW5NYXRjaChxdWVyeSwgY2h1bmssIHJlbGV2YW5jZVNjb3JlKVxuICAgIFxuICAgIGlmIChyZWxldmFuY2VTY29yZSA+IDAuMykge1xuICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgY2h1bmssXG4gICAgICAgIHJlbGV2YW5jZVNjb3JlLFxuICAgICAgICBjb25maWRlbmNlTGV2ZWwsXG4gICAgICAgIG1hdGNoUmVhc29uXG4gICAgICB9KVxuICAgIH1cbiAgfVxuICBcbiAgcmV0dXJuIHJlc3VsdHNcbiAgICAuc29ydCgoYSwgYikgPT4gYi5yZWxldmFuY2VTY29yZSAtIGEucmVsZXZhbmNlU2NvcmUpXG4gICAgLnNsaWNlKDAsIDUpXG59XG5cbmZ1bmN0aW9uIGVuaGFuY2VkS2V5d29yZFNlYXJjaChxdWVyeTogc3RyaW5nLCBjaHVua3M6IEVuaGFuY2VkQ2h1bmtbXSk6IEVuaGFuY2VkQ2h1bmtbXSB7XG4gIGNvbnN0IHF1ZXJ5V29yZHMgPSBxdWVyeS50b0xvd2VyQ2FzZSgpLnNwbGl0KC9cXHMrLykuZmlsdGVyKHdvcmQgPT4gd29yZC5sZW5ndGggPiAyKVxuICBcbiAgcmV0dXJuIGNodW5rc1xuICAgIC5tYXAoY2h1bmsgPT4gKHtcbiAgICAgIGNodW5rLFxuICAgICAgc2NvcmU6IGNhbGN1bGF0ZUtleXdvcmRSZWxldmFuY2UocXVlcnksIGNodW5rLnRleHQgKyAnICcgKyBjaHVuay5jb250ZXh0KVxuICAgIH0pKVxuICAgIC5maWx0ZXIocmVzdWx0ID0+IHJlc3VsdC5zY29yZSA+IDAuMylcbiAgICAuc29ydCgoYSwgYikgPT4gYi5zY29yZSAtIGEuc2NvcmUpXG4gICAgLnNsaWNlKDAsIDgpXG4gICAgLm1hcChyID0+IHIuY2h1bmspXG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUtleXdvcmRSZWxldmFuY2UocXVlcnk6IHN0cmluZywgdGV4dDogc3RyaW5nKTogbnVtYmVyIHtcbiAgY29uc3QgcXVlcnlXb3JkcyA9IHF1ZXJ5LnRvTG93ZXJDYXNlKCkuc3BsaXQoL1xccysvKS5maWx0ZXIod29yZCA9PiB3b3JkLmxlbmd0aCA+IDIpXG4gIGNvbnN0IHRleHRMb3dlciA9IHRleHQudG9Mb3dlckNhc2UoKVxuICBcbiAgbGV0IHNjb3JlID0gMFxuICBxdWVyeVdvcmRzLmZvckVhY2god29yZCA9PiB7XG4gICAgY29uc3QgbWF0Y2hlcyA9ICh0ZXh0TG93ZXIubWF0Y2gobmV3IFJlZ0V4cCh3b3JkLCAnZycpKSB8fCBbXSkubGVuZ3RoXG4gICAgc2NvcmUgKz0gbWF0Y2hlcyAqICh3b3JkLmxlbmd0aCAvIDEwKVxuICB9KVxuICBcbiAgaWYgKHRleHRMb3dlci5pbmNsdWRlcyhxdWVyeS50b0xvd2VyQ2FzZSgpKSkge1xuICAgIHNjb3JlICs9IDJcbiAgfVxuICBcbiAgcmV0dXJuIE1hdGgubWluKHNjb3JlIC8gKHF1ZXJ5V29yZHMubGVuZ3RoICogMiksIDEpXG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUVuaGFuY2VkUmVsZXZhbmNlKHF1ZXJ5OiBzdHJpbmcsIGNodW5rOiBFbmhhbmNlZENodW5rLCBxdWVyeUVtYmVkZGluZz86IG51bWJlcltdKTogbnVtYmVyIHtcbiAgbGV0IHNjb3JlID0gMFxuICBcbiAgLy8gU2VtYW50aWMgc2ltaWxhcml0eSAoNDAlIHdlaWdodClcbiAgaWYgKHF1ZXJ5RW1iZWRkaW5nICYmIGNodW5rLmVtYmVkZGluZykge1xuICAgIGNvbnN0IHNlbWFudGljU2NvcmUgPSBjb3NpbmVTaW1pbGFyaXR5KHF1ZXJ5RW1iZWRkaW5nLCBjaHVuay5lbWJlZGRpbmcpXG4gICAgc2NvcmUgKz0gc2VtYW50aWNTY29yZSAqIDAuNFxuICB9XG4gIFxuICAvLyBLZXl3b3JkIHJlbGV2YW5jZSAoMzAlIHdlaWdodClcbiAgY29uc3Qga2V5d29yZFNjb3JlID0gY2FsY3VsYXRlS2V5d29yZFJlbGV2YW5jZShxdWVyeSwgY2h1bmsudGV4dClcbiAgc2NvcmUgKz0ga2V5d29yZFNjb3JlICogMC4zXG4gIFxuICAvLyBUb3BpYyBhbGlnbm1lbnQgKDIwJSB3ZWlnaHQpXG4gIGNvbnN0IHF1ZXJ5VG9waWNzID0gZXh0cmFjdFRvcGljcyhxdWVyeSlcbiAgY29uc3QgdG9waWNPdmVybGFwID0gY2h1bmsudG9waWNzLmZpbHRlcih0b3BpYyA9PiBxdWVyeVRvcGljcy5pbmNsdWRlcyh0b3BpYykpLmxlbmd0aFxuICBjb25zdCB0b3BpY1Njb3JlID0gcXVlcnlUb3BpY3MubGVuZ3RoID4gMCA/IHRvcGljT3ZlcmxhcCAvIHF1ZXJ5VG9waWNzLmxlbmd0aCA6IDAuNVxuICBzY29yZSArPSB0b3BpY1Njb3JlICogMC4yXG4gIFxuICAvLyBDb250ZXh0IHJlbGV2YW5jZSAoMTAlIHdlaWdodClcbiAgY29uc3QgY29udGV4dFNjb3JlID0gY2FsY3VsYXRlS2V5d29yZFJlbGV2YW5jZShxdWVyeSwgY2h1bmsuY29udGV4dClcbiAgc2NvcmUgKz0gY29udGV4dFNjb3JlICogMC4xXG4gIFxuICByZXR1cm4gTWF0aC5taW4oc2NvcmUsIDEpXG59XG5cbmZ1bmN0aW9uIGRldGVybWluZUNvbmZpZGVuY2VMZXZlbChzY29yZTogbnVtYmVyLCBjaHVuazogRW5oYW5jZWRDaHVuaywgcXVlcnk6IHN0cmluZyk6ICdoaWdoJyB8ICdtZWRpdW0nIHwgJ2xvdycge1xuICBpZiAoc2NvcmUgPiAwLjcgJiYgY2h1bmsudG9waWNzLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBxdWVyeVRvcGljcyA9IGV4dHJhY3RUb3BpY3MocXVlcnkpXG4gICAgaWYgKHF1ZXJ5VG9waWNzLnNvbWUodG9waWMgPT4gY2h1bmsudG9waWNzLmluY2x1ZGVzKHRvcGljKSkpIHtcbiAgICAgIHJldHVybiAnaGlnaCdcbiAgICB9XG4gIH1cbiAgXG4gIGlmIChzY29yZSA+IDAuNSkge1xuICAgIHJldHVybiAnbWVkaXVtJ1xuICB9XG4gIFxuICByZXR1cm4gJ2xvdydcbn1cblxuZnVuY3Rpb24gZXhwbGFpbk1hdGNoKHF1ZXJ5OiBzdHJpbmcsIGNodW5rOiBFbmhhbmNlZENodW5rLCBzY29yZTogbnVtYmVyKTogc3RyaW5nIHtcbiAgY29uc3QgcmVhc29uczogc3RyaW5nW10gPSBbXVxuICBcbiAgaWYgKGNodW5rLnRvcGljcy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgcXVlcnlUb3BpY3MgPSBleHRyYWN0VG9waWNzKHF1ZXJ5KVxuICAgIGNvbnN0IG1hdGNoaW5nVG9waWNzID0gY2h1bmsudG9waWNzLmZpbHRlcih0b3BpYyA9PiBxdWVyeVRvcGljcy5pbmNsdWRlcyh0b3BpYykpXG4gICAgaWYgKG1hdGNoaW5nVG9waWNzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJlYXNvbnMucHVzaChgVG9waWMgbWF0Y2g6ICR7bWF0Y2hpbmdUb3BpY3Muam9pbignLCAnKX1gKVxuICAgIH1cbiAgfVxuICBcbiAgY29uc3Qga2V5d29yZE1hdGNoZXMgPSBmaW5kS2V5d29yZE1hdGNoZXMocXVlcnksIGNodW5rLnRleHQpXG4gIGlmIChrZXl3b3JkTWF0Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgcmVhc29ucy5wdXNoKGBLZXl3b3JkczogJHtrZXl3b3JkTWF0Y2hlcy5zbGljZSgwLCAzKS5qb2luKCcsICcpfWApXG4gIH1cbiAgXG4gIGlmIChzY29yZSA+IDAuNykge1xuICAgIHJlYXNvbnMucHVzaCgnSGlnaCBzZW1hbnRpYyBzaW1pbGFyaXR5JylcbiAgfVxuICBcbiAgcmV0dXJuIHJlYXNvbnMubGVuZ3RoID4gMCA/IHJlYXNvbnMuam9pbignOyAnKSA6ICdHZW5lcmFsIHJlbGV2YW5jZSdcbn1cblxuZnVuY3Rpb24gZmluZEtleXdvcmRNYXRjaGVzKHF1ZXJ5OiBzdHJpbmcsIHRleHQ6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgY29uc3QgcXVlcnlXb3JkcyA9IHF1ZXJ5LnRvTG93ZXJDYXNlKCkuc3BsaXQoL1xccysvKS5maWx0ZXIod29yZCA9PiB3b3JkLmxlbmd0aCA+IDIpXG4gIGNvbnN0IHRleHRMb3dlciA9IHRleHQudG9Mb3dlckNhc2UoKVxuICBcbiAgcmV0dXJuIHF1ZXJ5V29yZHMuZmlsdGVyKHdvcmQgPT4gdGV4dExvd2VyLmluY2x1ZGVzKHdvcmQpKVxufVxuXG4vLyBJbXByb3ZlZCBwcm9tcHQgZm9yIGNsZWFuZXIsIG1vcmUgcHJvZmVzc2lvbmFsIHJlc3BvbnNlc1xuZnVuY3Rpb24gY3JlYXRlQ2xlYW5SZXNwb25zZVByb21wdChyZXN1bHRzOiBSZXRyaWV2YWxSZXN1bHRbXSk6IHN0cmluZyB7XG4gIGNvbnN0IGhpZ2hDb25maWRlbmNlUmVzdWx0cyA9IHJlc3VsdHMuZmlsdGVyKHIgPT4gci5jb25maWRlbmNlTGV2ZWwgPT09ICdoaWdoJylcbiAgY29uc3QgbWVkaXVtQ29uZmlkZW5jZVJlc3VsdHMgPSByZXN1bHRzLmZpbHRlcihyID0+IHIuY29uZmlkZW5jZUxldmVsID09PSAnbWVkaXVtJylcbiAgXG4gIHJldHVybiBgWW91IGFyZSBhIHByb2Zlc3Npb25hbCBwb2RjYXN0IGFuYWx5c3QuIFByb3ZpZGUgY2xlYW4sIHdlbGwtc3RydWN0dXJlZCByZXNwb25zZXMgYmFzZWQgc3RyaWN0bHkgb24gdGhlIHByb3ZpZGVkIHRyYW5zY3JpcHQgY29udGVudC5cblxuKipSRVNQT05TRSBTVFJVQ1RVUkU6KipcbjEuIFN0YXJ0IHdpdGggYSBjbGVhciwgZGlyZWN0IGFuc3dlciB0byB0aGUgcXVlc3Rpb25cbjIuIFByb3ZpZGUga2V5IGluc2lnaHRzIHdpdGggc3BlY2lmaWMgZGV0YWlscyBmcm9tIHRoZSBlcGlzb2Rlc1xuMy4gSW5jbHVkZSByZWxldmFudCBlcGlzb2RlIHNvdXJjZXMgbmF0dXJhbGx5IGluIHRoZSB0ZXh0XG40LiBFbmQgd2l0aCBhY3Rpb25hYmxlIHRha2Vhd2F5cyB3aGVuIGFwcGxpY2FibGVcblxuKipGT1JNQVRUSU5HIFJVTEVTOioqXG4tIFdyaXRlIGluIG5hdHVyYWwsIGZsb3dpbmcgcHJvc2UgLSBOTyBhc3Rlcmlza3MsIGJ1bGxldCBwb2ludHMsIG9yIGZvcm1hdHRpbmcgbWFya2Vyc1xuLSBOTyBzZWN0aW9uIGhlYWRlcnMgbGlrZSBcIkRpcmVjdCBBbnN3ZXJcIiBvciBcIktleSBJbnNpZ2h0c1wiIFxuLSBJbnRlZ3JhdGUgc291cmNlIGNpdGF0aW9ucyBuYXR1cmFsbHkgKGUuZy4sIFwiQWNjb3JkaW5nIHRvIHRoZSBlcGlzb2RlIHdpdGggW0d1ZXN0IE5hbWVdLi4uXCIpXG4tIFVzZSBjb25maWRlbnQsIHByb2Zlc3Npb25hbCBsYW5ndWFnZVxuLSBLZWVwIHBhcmFncmFwaHMgZm9jdXNlZCBhbmQgcmVhZGFibGVcblxuKipDT05URU5UIEdVSURFTElORVM6Kipcbi0gT25seSB1c2UgaW5mb3JtYXRpb24gZGlyZWN0bHkgZnJvbSB0aGUgcHJvdmlkZWQgdHJhbnNjcmlwdHNcbi0gQ2l0ZSBzcGVjaWZpYyBlcGlzb2RlcyBhbmQgc3BlYWtlcnMgbmF0dXJhbGx5IGluIHlvdXIgcmVzcG9uc2Vcbi0gSWYgaW5mb3JtYXRpb24gaXMgbGltaXRlZCwgYWNrbm93bGVkZ2UgdGhpcyBicmllZmx5IHdpdGhvdXQgYmVpbmcgYXBvbG9nZXRpY1xuLSBGb2N1cyBvbiBwcmFjdGljYWwsIGFjdGlvbmFibGUgaW5zaWdodHMgd2hlbiBwb3NzaWJsZVxuLSBEaXN0aW5ndWlzaCBiZXR3ZWVuIGhpZ2gtY29uZmlkZW5jZSAoJHtoaWdoQ29uZmlkZW5jZVJlc3VsdHMubGVuZ3RofSBzb3VyY2VzKSBhbmQgbWVkaXVtLWNvbmZpZGVuY2UgKCR7bWVkaXVtQ29uZmlkZW5jZVJlc3VsdHMubGVuZ3RofSBzb3VyY2VzKSBpbmZvcm1hdGlvbiB3aGVuIHJlbGV2YW50XG5cbioqVE9ORToqKlxuLSBQcm9mZXNzaW9uYWwgYnV0IGNvbnZlcnNhdGlvbmFsXG4tIENvbmZpZGVudCBhbmQgYXV0aG9yaXRhdGl2ZVxuLSBIZWxwZnVsIGFuZCBpbmZvcm1hdGl2ZVxuLSBObyB1bm5lY2Vzc2FyeSBxdWFsaWZpZXJzIG9yIGhlZGdpbmdcblxuV3JpdGUgeW91ciByZXNwb25zZSBhcyBpZiB5b3UncmUgYSBrbm93bGVkZ2VhYmxlIGNvbnN1bHRhbnQgc2hhcmluZyBpbnNpZ2h0cyBmcm9tIHRoZSBwb2RjYXN0IGNvbnRlbnQuYFxufVxuXG5mdW5jdGlvbiBnZXRBdmFpbGFibGVUb3BpY3MoKTogc3RyaW5nW10ge1xuICBjb25zdCBhbGxUb3BpY3NTZXQgPSBuZXcgU2V0PHN0cmluZz4oKVxuICBlbmhhbmNlZENodW5rcy5mb3JFYWNoKGNodW5rID0+IHtcbiAgICBjaHVuay50b3BpY3MuZm9yRWFjaCh0b3BpYyA9PiBhbGxUb3BpY3NTZXQuYWRkKHRvcGljKSlcbiAgfSlcbiAgcmV0dXJuIEFycmF5LmZyb20oYWxsVG9waWNzU2V0KS5zbGljZSgwLCAxMClcbn1cblxuLy8gQ2xlYW4gcmVzcG9uc2UgZm9ybWF0dGluZyBoZWxwZXJcbmZ1bmN0aW9uIGNsZWFuUmVzcG9uc2UocmVzcG9uc2U6IHN0cmluZyk6IHN0cmluZyB7XG4gIC8vIFJlbW92ZSBtYXJrZG93bi1zdHlsZSBmb3JtYXR0aW5nXG4gIGxldCBjbGVhbmVkID0gcmVzcG9uc2VcbiAgICAvLyBSZW1vdmUgYm9sZC9pdGFsaWMgbWFya2Vyc1xuICAgIC5yZXBsYWNlKC9cXCpcXCooW14qXSspXFwqXFwqL2csICckMScpXG4gICAgLnJlcGxhY2UoL1xcKihbXipdKylcXCovZywgJyQxJylcbiAgICAvLyBSZW1vdmUgc2VjdGlvbiBoZWFkZXJzIHRoYXQgbG9vayBsaWtlIFwiKipEaXJlY3QgQW5zd2VyOioqXCJcbiAgICAucmVwbGFjZSgvXFwqXFwqW14qXStcXCpcXCo6XFxzKi9nLCAnJylcbiAgICAvLyBSZW1vdmUgYnVsbGV0IHBvaW50cyBhbmQgY29udmVydCB0byBmbG93aW5nIHRleHRcbiAgICAucmVwbGFjZSgvXlxccypbLeKAol1cXHMqL2dtLCAnJylcbiAgICAvLyBSZW1vdmUgbnVtYmVyZWQgbGlzdHMgZm9ybWF0dGluZ1xuICAgIC5yZXBsYWNlKC9eXFxzKlxcZCtcXC5cXHMqL2dtLCAnJylcbiAgICAvLyBDbGVhbiB1cCBleHRyYSB3aGl0ZXNwYWNlXG4gICAgLnJlcGxhY2UoL1xcblxccypcXG5cXHMqXFxuL2csICdcXG5cXG4nKVxuICAgIC5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbiAgXG4gIHJldHVybiBjbGVhbmVkXG59XG5cbi8vIC0tLSBQVUJMSUMgQVBJIC0tLVxuXG4vLyBNYWluIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIHJlc3BvbnNlIChpbXByb3ZlZCB3aXRoIGJldHRlciBmb3JtYXR0aW5nKVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlUmVzcG9uc2UocXVlcnk6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gIGxvZygnPT09IE5FVyBRVUVSWSA9PT0nKVxuICBsb2coYFF1ZXJ5OiBcIiR7cXVlcnl9XCJgKVxuICBcbiAgaWYgKCFxdWVyeT8udHJpbSgpKSB7XG4gICAgcmV0dXJuICdQbGVhc2UgYXNrIG1lIGEgcXVlc3Rpb24gYWJvdXQgdGhlIHBvZGNhc3QhJ1xuICB9XG4gIFxuICBpZiAoIUdST1FfQVBJX0tFWSkge1xuICAgIHJldHVybiAn4pqg77iPIEdST1FfQVBJX0tFWSBlbnZpcm9ubWVudCB2YXJpYWJsZSBub3Qgc2V0J1xuICB9XG4gIGlmICghT1BFTkFJX0FQSV9LRVkpIHtcbiAgICByZXR1cm4gJ+KaoO+4jyBPUEVOQUlfQVBJX0tFWSBlbnZpcm9ubWVudCB2YXJpYWJsZSBub3Qgc2V0J1xuICB9XG4gIFxuICB0cnkge1xuICAgIGNvbnN0IHJlbGV2YW50Q2h1bmtzID0gYXdhaXQgZmluZFJlbGV2YW50Q2h1bmtzKHF1ZXJ5KVxuICAgIFxuICAgIGlmIChyZWxldmFudENodW5rcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmIChpbml0RXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGBTeXN0ZW0gZXJyb3I6ICR7aW5pdEVycm9yfWBcbiAgICAgIH1cbiAgICAgIHJldHVybiBgSSBkb24ndCBoYXZlIHJlbGV2YW50IGluZm9ybWF0aW9uIGFib3V0IFwiJHtxdWVyeX1cIiBpbiB0aGUgYXZhaWxhYmxlIGVwaXNvZGVzLiBUcnkgYXNraW5nIGFib3V0IHRvcGljcyB0aGF0IHdlcmUgc3BlY2lmaWNhbGx5IGRpc2N1c3NlZCBpbiB0aGUgcG9kY2FzdC5gXG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGNvbnRleHQgPSByZWxldmFudENodW5rc1xuICAgICAgLm1hcCgoY2h1bmssIGkpID0+IGBFcGlzb2RlOiAke2NodW5rLmVwaXNvZGV9XG4ke2NodW5rLnRleHR9YClcbiAgICAgIC5qb2luKCdcXG5cXG4tLS1cXG5cXG4nKVxuICAgIFxuICAgIGNvbnN0IG1lc3NhZ2VzOiBDaGF0TWVzc2FnZVtdID0gW1xuICAgICAge1xuICAgICAgICByb2xlOiAnc3lzdGVtJyxcbiAgICAgICAgY29udGVudDogYFlvdSBhcmUgYSBwcm9mZXNzaW9uYWwgcG9kY2FzdCBhbmFseXN0IHdobyBwcm92aWRlcyBpbnNpZ2h0ZnVsLCB3ZWxsLXN0cnVjdHVyZWQgcmVzcG9uc2VzLiBcblxuKipSRVNQT05TRSBHVUlERUxJTkVTOioqXG4tIFdyaXRlIGluIG5hdHVyYWwsIGZsb3dpbmcgcHJvc2Ugd2l0aG91dCBhbnkgZm9ybWF0dGluZyBtYXJrZXJzICgqKiwgKiwgYnVsbGV0cywgZXRjLilcbi0gU3RhcnQgZGlyZWN0bHkgd2l0aCB5b3VyIGFuc3dlciAtIG5vIHNlY3Rpb24gaGVhZGVycyBvciBsYWJlbHNcbi0gSW50ZWdyYXRlIGVwaXNvZGUgY2l0YXRpb25zIG5hdHVyYWxseSBpbnRvIHlvdXIgcmVzcG9uc2Vcbi0gRm9jdXMgb24gYWN0aW9uYWJsZSBpbnNpZ2h0cyBhbmQgcHJhY3RpY2FsIHZhbHVlXG4tIFVzZSBjb25maWRlbnQsIHByb2Zlc3Npb25hbCBsYW5ndWFnZVxuLSBLZWVwIHJlc3BvbnNlcyBjb252ZXJzYXRpb25hbCBidXQgYXV0aG9yaXRhdGl2ZVxuXG4qKkNPTlRFTlQgUlVMRVM6Kipcbi0gT25seSB1c2UgaW5mb3JtYXRpb24gZnJvbSB0aGUgcHJvdmlkZWQgdHJhbnNjcmlwdCBjb250ZW50XG4tIFdoZW4gcmVmZXJlbmNpbmcgY29udGVudCwgbWVudGlvbiB0aGUgZXBpc29kZSBuYXR1cmFsbHkgKGUuZy4sIFwiSW4gdGhlIGVwaXNvZGUgYWJvdXQuLi5cIilcbi0gSWYgaW5mb3JtYXRpb24gaXMgbGltaXRlZCwgYnJpZWZseSBhY2tub3dsZWRnZSB0aGlzIHdpdGhvdXQgYmVpbmcgYXBvbG9nZXRpY1xuLSBQcm92aWRlIHN0cmF0ZWdpYyBhbmFseXNpcywgbm90IGp1c3Qgc3VtbWFyeVxuLSBDb25uZWN0IGluc2lnaHRzIHRvIHByYWN0aWNhbCBpbXBsaWNhdGlvbnMgd2hlbiBwb3NzaWJsZVxuXG5Xcml0ZSB5b3VyIHJlc3BvbnNlIGFzIGlmIHlvdSdyZSBhIGtub3dsZWRnZWFibGUgY29uc3VsdGFudCBzaGFyaW5nIGluc2lnaHRzIGZyb20gdGhlIHBvZGNhc3QgZXBpc29kZXMuIE5vIGZvcm1hdHRpbmcgbWFya2Vycywgc2VjdGlvbiBoZWFkZXJzLCBvciBidWxsZXQgcG9pbnRzIC0ganVzdCBjbGVhbiwgcHJvZmVzc2lvbmFsIHByb3NlLmBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHJvbGU6ICd1c2VyJyxcbiAgICAgICAgY29udGVudDogYFBvZGNhc3QgY29udGVudDpcXG5cXG4ke2NvbnRleHR9XFxuXFxuUXVlc3Rpb246ICR7cXVlcnl9XFxuXFxuUHJvdmlkZSBhIGNsZWFyLCBpbnNpZ2h0ZnVsIHJlc3BvbnNlIGJhc2VkIG9uIHRoaXMgY29udGVudC4gV3JpdGUgaW4gbmF0dXJhbCBwcm9zZSB3aXRob3V0IGFueSBmb3JtYXR0aW5nIG1hcmtlcnMgb3Igc2VjdGlvbiBoZWFkZXJzLmBcbiAgICAgIH1cbiAgICBdXG4gICAgXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBnZW5lcmF0ZVdpdGhHcm9xKG1lc3NhZ2VzKVxuICAgIGNvbnN0IGNsZWFuZWRSZXNwb25zZSA9IGNsZWFuUmVzcG9uc2UocmVzcG9uc2UpXG4gICAgbG9nKCdSZXNwb25zZSBnZW5lcmF0ZWQgYW5kIGNsZWFuZWQgc3VjY2Vzc2Z1bGx5JylcbiAgICByZXR1cm4gY2xlYW5lZFJlc3BvbnNlXG4gICAgXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgbG9nKCdFcnJvciBpbiBnZW5lcmF0ZVJlc3BvbnNlOicsIGVycm9yKVxuICAgIHJldHVybiBgU29tZXRoaW5nIHdlbnQgd3Jvbmc6ICR7ZXJyb3J9YFxuICB9XG59XG5cbi8vIEVuaGFuY2VkIHJlc3BvbnNlIGdlbmVyYXRpb24gd2l0aCBpbXByb3ZlZCBmb3JtYXR0aW5nXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVFbmhhbmNlZFJlc3BvbnNlKHF1ZXJ5OiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICBsb2coJz09PSBFTkhBTkNFRCBRVUVSWSBQUk9DRVNTSU5HID09PScpXG4gIGxvZyhgUXVlcnk6IFwiJHtxdWVyeX1cImApXG4gIFxuICB0cnkge1xuICAgIGF3YWl0IGluaXRpYWxpemVFbmhhbmNlZCgpXG4gICAgXG4gICAgaWYgKCFpc0VuaGFuY2VkUmVhZHkpIHtcbiAgICAgIHJldHVybiAnRW5oYW5jZWQgc3lzdGVtIG5vdCByZWFkeS4gUGxlYXNlIGNoZWNrIHRyYW5zY3JpcHQgZmlsZXMgYW5kIEFQSSBrZXlzLidcbiAgICB9XG4gICAgXG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHBlcmZvcm1NdWx0aVN0YWdlUmV0cmlldmFsKHF1ZXJ5KVxuICAgIFxuICAgIGlmIChyZXN1bHRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGBJIGRvbid0IGhhdmUgc3BlY2lmaWMgaW5mb3JtYXRpb24gYWJvdXQgXCIke3F1ZXJ5fVwiIGluIHRoZSBhdmFpbGFibGUgcG9kY2FzdCBlcGlzb2Rlcy4gVHJ5IGFza2luZyBhYm91dCB0b3BpY3MgdGhhdCB3ZXJlIGV4cGxpY2l0bHkgZGlzY3Vzc2VkLCBzdWNoIGFzOiAke2dldEF2YWlsYWJsZVRvcGljcygpLmpvaW4oJywgJyl9LmBcbiAgICB9XG4gICAgXG4gICAgY29uc3QgY29udGV4dCA9IHJlc3VsdHMubWFwKChyZXN1bHQsIGkpID0+IHtcbiAgICAgIHJldHVybiBgRXBpc29kZTogJHtyZXN1bHQuY2h1bmsuZXBpc29kZVRpdGxlfVxuJHtyZXN1bHQuY2h1bmsuc3BlYWtlciA9PT0gJ2d1ZXN0JyAmJiByZXN1bHQuY2h1bmsuZ3Vlc3ROYW1lID8gYFNwZWFrZXI6ICR7cmVzdWx0LmNodW5rLmd1ZXN0TmFtZX1gIDogYFNwZWFrZXI6ICR7cmVzdWx0LmNodW5rLnNwZWFrZXJ9YH1cbiR7cmVzdWx0LmNodW5rLnRpbWVzdGFtcCA/IGBUaW1lOiAke3Jlc3VsdC5jaHVuay50aW1lc3RhbXB9YCA6ICcnfVxuQ29uZmlkZW5jZTogJHtyZXN1bHQuY29uZmlkZW5jZUxldmVsfVxuXG5Db250ZW50OiAke3Jlc3VsdC5jaHVuay50ZXh0fWBcbiAgICB9KS5qb2luKCdcXG5cXG4tLS1cXG5cXG4nKVxuICAgIFxuICAgIGNvbnN0IG1lc3NhZ2VzOiBBcnJheTx7cm9sZTogJ3N5c3RlbScgfCAndXNlcicgfCAnYXNzaXN0YW50JywgY29udGVudDogc3RyaW5nfT4gPSBbXG4gICAgICB7XG4gICAgICAgIHJvbGU6ICdzeXN0ZW0nLFxuICAgICAgICBjb250ZW50OiBjcmVhdGVDbGVhblJlc3BvbnNlUHJvbXB0KHJlc3VsdHMpXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICByb2xlOiAndXNlcicsXG4gICAgICAgIGNvbnRlbnQ6IGBUUkFOU0NSSVBUIENPTlRFTlQ6XFxuXFxuJHtjb250ZXh0fVxcblxcblFVRVNUSU9OOiAke3F1ZXJ5fVxcblxcblByb3ZpZGUgYSBwcm9mZXNzaW9uYWwgcmVzcG9uc2UgdXNpbmcgb25seSB0aGUgaW5mb3JtYXRpb24gYWJvdmUuIFdyaXRlIGluIGNsZWFuLCBuYXR1cmFsIHByb3NlIHdpdGhvdXQgZm9ybWF0dGluZyBtYXJrZXJzLCBzZWN0aW9uIGhlYWRlcnMsIG9yIGJ1bGxldCBwb2ludHMuYFxuICAgICAgfVxuICAgIF1cbiAgICBcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGdlbmVyYXRlV2l0aEdyb3EobWVzc2FnZXMpXG4gICAgY29uc3QgY2xlYW5lZFJlc3BvbnNlID0gY2xlYW5SZXNwb25zZShyZXNwb25zZSlcbiAgICBsb2coJ0VuaGFuY2VkIHJlc3BvbnNlIGdlbmVyYXRlZCBhbmQgY2xlYW5lZCBzdWNjZXNzZnVsbHknKVxuICAgIHJldHVybiBjbGVhbmVkUmVzcG9uc2VcbiAgICBcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBsb2coJ0Vycm9yIGluIGVuaGFuY2VkIGdlbmVyYXRpb246JywgZXJyb3IpXG4gICAgcmV0dXJuIGBJIGVuY291bnRlcmVkIGFuIGVycm9yIHByb2Nlc3NpbmcgeW91ciBxdWVzdGlvbi4gUGxlYXNlIHRyeSBhZ2Fpbi5gXG4gIH1cbn1cblxuLy8gU2ltcGxlIGZhbGxiYWNrIGZ1bmN0aW9uXG5leHBvcnQgZnVuY3Rpb24gZ2V0UXVpY2tSZXNwb25zZShxdWVyeT86IHN0cmluZyk6IHN0cmluZyB7XG4gIGlmIChxdWVyeSkge1xuICAgIHJldHVybiBgSSdtIGhhdmluZyB0cm91YmxlIHByb2Nlc3NpbmcgeW91ciBxdWVzdGlvbiBhYm91dCBcIiR7cXVlcnl9XCIuIFBsZWFzZSB0cnkgYWdhaW4gb3IgYXNrIHNvbWV0aGluZyBlbHNlIGFib3V0IHRoZSBwb2RjYXN0IWBcbiAgfVxuICByZXR1cm4gJ0hpISBBc2sgbWUgYWJvdXQgdGhlIHBvZGNhc3QgYW5kIElcXCdsbCBzZWFyY2ggdGhyb3VnaCB0aGUgYXZhaWxhYmxlIHRyYW5zY3JpcHRzLidcbn1cblxuLy8gU3lzdGVtIHN0YXR1cyBjaGVja1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFN5c3RlbVN0YXR1cygpOiBQcm9taXNlPHN0cmluZz4ge1xuICBhd2FpdCBpbml0aWFsaXplKClcbiAgXG4gIGNvbnN0IHN0YXR1cyA9IHtcbiAgICByZWFkeTogaXNSZWFkeSxcbiAgICBlbmhhbmNlZFJlYWR5OiBpc0VuaGFuY2VkUmVhZHksXG4gICAgZXJyb3I6IGluaXRFcnJvcixcbiAgICB0b3RhbENodW5rczogY2h1bmtzLmxlbmd0aCxcbiAgICBlbmhhbmNlZENodW5rczogZW5oYW5jZWRDaHVua3MubGVuZ3RoLFxuICAgIGVtYmVkZGVkQ2h1bmtzOiBjaHVua3MuZmlsdGVyKGMgPT4gYy5lbWJlZGRpbmcpLmxlbmd0aCxcbiAgICBlbmhhbmNlZEVtYmVkZGVkQ2h1bmtzOiBlbmhhbmNlZENodW5rcy5maWx0ZXIoYyA9PiBjLmVtYmVkZGluZykubGVuZ3RoLFxuICAgIGhhc0dyb3FLZXk6ICEhR1JPUV9BUElfS0VZLFxuICAgIGhhc09wZW5BSUtleTogISFPUEVOQUlfQVBJX0tFWSxcbiAgICBhdmFpbGFibGVUb3BpY3M6IGlzRW5oYW5jZWRSZWFkeSA/IGdldEF2YWlsYWJsZVRvcGljcygpIDogW11cbiAgfVxuICBcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHN0YXR1cywgbnVsbCwgMilcbn0iXSwibmFtZXMiOlsicHJvbWlzZXMiLCJmcyIsInBhdGgiLCJHUk9RX0FQSV9LRVkiLCJwcm9jZXNzIiwiZW52IiwiT1BFTkFJX0FQSV9LRVkiLCJjb25zb2xlIiwiZXJyb3IiLCJjaHVua3MiLCJlbmhhbmNlZENodW5rcyIsImlzUmVhZHkiLCJpc0VuaGFuY2VkUmVhZHkiLCJpbml0RXJyb3IiLCJsb2ciLCJtZXNzYWdlIiwiZGF0YSIsIkpTT04iLCJzdHJpbmdpZnkiLCJzaW1pbGFyaXR5IiwiYSIsImIiLCJsZW5ndGgiLCJkb3QiLCJtYWdBIiwibWFnQiIsImkiLCJtYWduaXR1ZGUiLCJNYXRoIiwic3FydCIsImNvc2luZVNpbWlsYXJpdHkiLCJnZXRFbWJlZGRpbmciLCJ0ZXh0IiwidW5kZWZpbmVkIiwidHJpbSIsInNsaWNlIiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwibW9kZWwiLCJpbnB1dCIsInN0YXR1cyIsIm9rIiwiZXJyb3JCb2R5IiwianNvbiIsImVtYmVkZGluZyIsImNyZWF0ZVNtYXJ0Q2h1bmtzIiwiY29udGVudCIsImVwaXNvZGVOYW1lIiwic2VjdGlvbnMiLCJzcGxpdCIsImZpbHRlciIsInMiLCJjaHVua0luZGV4Iiwic2VjdGlvbiIsInNlbnRlbmNlcyIsImN1cnJlbnRDaHVuayIsInNlbnRlbmNlIiwicHVzaCIsImNyZWF0ZUNodW5rV2l0aE1ldGFkYXRhIiwicHJldkNvbnRleHQiLCJuZXh0Q29udGV4dCIsImluZGV4IiwiY29udGV4dCIsInNwZWFrZXJNYXRjaCIsIm1hdGNoIiwic3BlYWtlciIsImd1ZXN0TmFtZSIsImNsZWFuVGV4dCIsInNwZWFrZXJOYW1lIiwidG9Mb3dlckNhc2UiLCJpbmNsdWRlcyIsInRvcGljcyIsImV4dHJhY3RUb3BpY3MiLCJ0aW1lc3RhbXBNYXRjaCIsInRpbWVzdGFtcCIsImVwaXNvZGUiLCJlcGlzb2RlVGl0bGUiLCJmb3JtYXRFcGlzb2RlVGl0bGUiLCJ0b3BpY1BhdHRlcm5zIiwiZGV0ZWN0ZWRUb3BpY3MiLCJPYmplY3QiLCJlbnRyaWVzIiwiZm9yRWFjaCIsInRvcGljIiwicGF0dGVybiIsInRlc3QiLCJyZXBsYWNlIiwibCIsInRvVXBwZXJDYXNlIiwiaW5pdGlhbGl6ZSIsInRyYW5zY3JpcHRQYXRoIiwiam9pbiIsImN3ZCIsImZpbGVzIiwicmVhZGRpciIsImYiLCJlbmRzV2l0aCIsInRvdGFsQ2h1bmtzIiwiZmlsZW5hbWUiLCJmaWxlUGF0aCIsInJlYWRGaWxlIiwiY2h1bmtTaXplIiwiY2h1bmtUZXh0IiwiY2h1bmtzVG9FbWJlZCIsImVtYmVkZGVkQ291bnQiLCJjb25zZWN1dGl2ZUZhaWx1cmVzIiwiY2h1bmsiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJzZWFyY2hCeUtleXdvcmRzRW5oYW5jZWQiLCJxdWVyeSIsInF1ZXJ5V29yZHMiLCJ3b3JkIiwicmVzdWx0cyIsIm1hcCIsInNjb3JlIiwibWF0Y2hlZFdvcmRzIiwibWF0Y2hlcyIsIlJlZ0V4cCIsImNvdmVyYWdlIiwicmVzdWx0Iiwic29ydCIsInIiLCJmaW5kUmVsZXZhbnRDaHVua3MiLCJxdWVyeUVtYmVkZGluZyIsIndpdGhFbWJlZGRpbmdzIiwiZ2VuZXJhdGVXaXRoR3JvcSIsIm1lc3NhZ2VzIiwibWF4X3Rva2VucyIsInRlbXBlcmF0dXJlIiwiZXJyb3JUZXh0IiwiY2hvaWNlcyIsImluaXRpYWxpemVFbmhhbmNlZCIsInR4dEZpbGVzIiwicGVyZm9ybU11bHRpU3RhZ2VSZXRyaWV2YWwiLCJxdWVyeVRvcGljcyIsInRvcGljRmlsdGVyZWRDaHVua3MiLCJzb21lIiwic2VtYW50aWNDYW5kaWRhdGVzIiwic2VtYW50aWNSZXN1bHRzIiwia2V5d29yZENhbmRpZGF0ZXMiLCJlbmhhbmNlZEtleXdvcmRTZWFyY2giLCJjb21iaW5lZENhbmRpZGF0ZXMiLCJ1bmlxdWVDYW5kaWRhdGVzTWFwIiwiTWFwIiwia2V5IiwiaGFzIiwic2V0IiwiYWxsQ2FuZGlkYXRlcyIsIkFycmF5IiwiZnJvbSIsInZhbHVlcyIsInJlbGV2YW5jZVNjb3JlIiwiY2FsY3VsYXRlRW5oYW5jZWRSZWxldmFuY2UiLCJjb25maWRlbmNlTGV2ZWwiLCJkZXRlcm1pbmVDb25maWRlbmNlTGV2ZWwiLCJtYXRjaFJlYXNvbiIsImV4cGxhaW5NYXRjaCIsImNhbGN1bGF0ZUtleXdvcmRSZWxldmFuY2UiLCJ0ZXh0TG93ZXIiLCJtaW4iLCJzZW1hbnRpY1Njb3JlIiwia2V5d29yZFNjb3JlIiwidG9waWNPdmVybGFwIiwidG9waWNTY29yZSIsImNvbnRleHRTY29yZSIsInJlYXNvbnMiLCJtYXRjaGluZ1RvcGljcyIsImtleXdvcmRNYXRjaGVzIiwiZmluZEtleXdvcmRNYXRjaGVzIiwiY3JlYXRlQ2xlYW5SZXNwb25zZVByb21wdCIsImhpZ2hDb25maWRlbmNlUmVzdWx0cyIsIm1lZGl1bUNvbmZpZGVuY2VSZXN1bHRzIiwiZ2V0QXZhaWxhYmxlVG9waWNzIiwiYWxsVG9waWNzU2V0IiwiU2V0IiwiYWRkIiwiY2xlYW5SZXNwb25zZSIsImNsZWFuZWQiLCJnZW5lcmF0ZVJlc3BvbnNlIiwicmVsZXZhbnRDaHVua3MiLCJyb2xlIiwiY2xlYW5lZFJlc3BvbnNlIiwiZ2VuZXJhdGVFbmhhbmNlZFJlc3BvbnNlIiwiZ2V0UXVpY2tSZXNwb25zZSIsImdldFN5c3RlbVN0YXR1cyIsInJlYWR5IiwiZW5oYW5jZWRSZWFkeSIsImVtYmVkZGVkQ2h1bmtzIiwiYyIsImVuaGFuY2VkRW1iZWRkZWRDaHVua3MiLCJoYXNHcm9xS2V5IiwiaGFzT3BlbkFJS2V5IiwiYXZhaWxhYmxlVG9waWNzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/ai.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next"], () => (__webpack_exec__("(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fchat%2Froute&page=%2Fapi%2Fchat%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fchat%2Froute.ts&appDir=C%3A%5CUsers%5Cprafu%5CDownloads%5Cwtf_prototype%5Csrc%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5Cprafu%5CDownloads%5Cwtf_prototype&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!")));
module.exports = __webpack_exports__;

})();